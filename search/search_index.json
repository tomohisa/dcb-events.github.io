{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Dynamic Consistency Boundary","text":"DCB A simpler and more flexible approach to consistency in event-driven systems"},{"location":"#what-is-it","title":"What is it?","text":"<p>Dynamic Consistency Boundary (DCB) is a technique for enforcing consistency in event-driven systems without relying on rigid transactional boundaries.</p> <p>Traditional systems use strict constraints to maintain immediate consistency, while event-driven architectures embrace eventual consistency for scalability and resilience. However, this flexibility raises challenges in defining where and how consistency should be enforced.</p> <p>Introduced by Sara Pellegrini in her blog post \"Killing the Aggregate\", DCB provides a pragmatic approach to balancing strong consistency with flexibility. DCB allows for the selective enforcement of strong consistency where needed, particularly for operations that span multiple entities. This ensures critical business processes and cross-entity invariants remain reliable while avoiding the constraints of traditional transactional models. DCB helps teams optimize performance, scalability, and operational correctness by defining context-sensitive consistency boundaries.</p>"},{"location":"#how-it-works","title":"How it works","text":"<p>To illustrate how DCB works, it makes sense first to explain the traditional Event Sourcing approach and its main issue:</p> <p>In her blog post, Sara describes an example application that allows students to subscribe to courses. In this example, we assume the constraints applied to the student and the course to ensure their integrity are invariants. In other words, those constraints must always be satisfied before transitioning to a new state. For this reason, the student and the course are typically implemented as Aggregates.</p> <p>But then, constraints that affect both entities are introduced, namely:</p> <ul> <li>a course cannot accept more than n students</li> <li>a student cannot subscribe to more than 10 courses</li> </ul>"},{"location":"#traditional-approach","title":"Traditional approach","text":"<p>In many contexts, it is impossible to update two Aggregates with a single transaction; for this reason, such requirements are usually solved with a Saga that coordinates the process:</p> <ol> <li>Mark the student to be subscribed by publishing an Event to the Event Stream of the student</li> <li>Potentially in parallel, mark the course by publishing an Event to the Event Stream of the affected course</li> <li>If one of the two previous operations fails due to constraint violations (e.g. because another student was subscribed to the same course in the meantime), append some compensating Event </li> </ol> <p></p> <p>This approach poses some issues in terms of added complexity and unwanted side effects (e.g. the state of the system being incorrect for a short period of time).</p> <p>But even for the happy path, the implementation leads to two Events being published that represent the same fact.</p>"},{"location":"#dcb-approach","title":"DCB approach","text":"<p>DCB solves this issue by allowing Events to be tagged when they are published. This allows one Event to affect multiple entities/concepts in the same bounded context.</p> <p>As a result, there is only a single Event Stream per bounded context, and the example above can be simplified to:</p> <p></p>"},{"location":"#reading-events","title":"Reading Events","text":"<p>A DCB compliant Event Store allows to filter Events by their Type and/or Tags.</p> <p>To determine how many students are enrolled in a course, simply count the subscription Events tagged with that course's identifier. Similarly, to find out how many courses a student is subscribed to, count the subscription Events tagged with that student's identifier.</p> <p>Those queries can be combined. To find out...</p> <ul> <li>...whether the course with a specified id (e.g. <code>c1</code>) exists</li> <li>...whether the student with the specified id (e.g. <code>s1</code>) exists</li> <li>...how many students are subscribed to a course</li> <li>...and how many courses the student is subscribed to</li> </ul> <p>the following query items can be specified (pseudo code):</p> <pre><code>[\n  {\n    \"event_type\": \"course defined\",\n    \"tag\": \"course:c1\"\n  },\n  {\n    \"event_type\": \"student registered\",\n    \"tag\": \"student:s1\"\n  },\n  {\n    \"event_type\": \"student subscribed to course\",\n    \"tag\": \"course:c1\"\n  },\n  {\n    \"event_type\": \"student subscribed to course\",\n    \"tag\": \"student:s1\"\n  }\n]\n</code></pre> <p>As a result, only the Events matching the specified query will be returned:</p> <ul> <li>one for the <code>course defined</code> Event (if the course exists)</li> <li>one for the <code>student registered</code> Event (if the student was registered)</li> <li>one for each subscription to the course</li> <li>one for each subscription of the student</li> </ul> <p>Info</p> <p>Usually those queries wouldn't be written manually. Instead, they can be automatically deferred from the decision model definition as demonstrated by some of the Examples</p>"},{"location":"#writing-events","title":"Writing Events","text":"<p>Similar to a traditional Event Store, DCB can enforce consistency when persisting Events using Optimistic Locking.</p> <p>However, unlike the traditional approach, DCB does not rely on streams/revisions. Instead, it passes the same query used to read Events for building the in-memory decision model, along with the position of the last Event the client was aware of when building the decision model. The DCB Event Store then ensures that no new Events matching the same query were added in the meantime.</p> <p>This can be compared to the \"expected revision\" mechanism of traditional Event Stores but does not require the Event Store to be split up into streams in order to allow for parallel, unrelated, writes.</p>"},{"location":"#getting-started","title":"Getting started","text":"<ul> <li>Visit the Examples section to explore various use cases for DCB</li> <li>The Related topics section provides in-depth articles on additional subjects related to DCB</li> <li>To begin using DCB, refer to the Libraries section</li> <li>If you want to understand the underlying workings or create your own implementation, read the Specification</li> </ul>"},{"location":"about/","title":"About this website","text":"<p>This website was created with the aim of spreading awareness about the concept of the Dynamic Consistency Boundary (DCB).</p> <p>Our goals are threefold:</p> <ol> <li>Explain the rationale behind the DCB approach</li> <li>Provide a practical guide for those who want to start applying it</li> <li>Collect and organize as many resources as possible on this topic</li> </ol> <p>This is a non-commercial project. We have no financial interest or sponsorship: our motivation is purely educational and driven by a desire to contribute to the tech community.</p> <p>We believe DCB can be a significant step forward in the design and management of complex systems, and we want to help make it accessible to anyone interested.</p>"},{"location":"about/#who-we-are","title":"Who We Are","text":"<p>Bastian Waidelich</p> <p>Self-employed Software Architect, Consultant</p> <p> |   | </p> <p></p> <p>Sara Pellegrini</p> <p>Software Engineer at Particular Software</p> <p> |   | </p> <p></p> <p>Paul Grimshaw</p> <p>Head of Software Engineering for Asset Management at Kraken</p> <p> |   | </p>"},{"location":"about/#contact-us","title":"Contact Us","text":"<p>For collaborations, suggestions, or just to connect, feel free to reach out to us via email  or through our social profiles.</p> <p>Also, feel free to join the discussions at the footer of each page or via the Github Repository of this website </p>"},{"location":"faq/","title":"FAQ","text":"<p>Some common questions and misconceptions about DCB:</p>"},{"location":"faq/#who-are-you-and-what-is-this-website-all-about","title":"Who are you and what is this website all about?","text":"<p>See about.</p>"},{"location":"faq/#whats-the-new-idea-about-dcb","title":"What's the new idea about DCB?","text":"<p>The core idea of DBC is simple: Allowing Events to be assigned to multiple domain concepts and to dynamically enforce consistency amongst them. The consequences, however, are broad because DCB can greatly improve the way you design your applications.</p>"},{"location":"faq/#does-dcb-promote-lack-of-modeling","title":"Does DCB promote lack of modeling?","text":"<p>Definitely not, on the contrary: It aims to reduce technical friction so that one can focus on the domain and be more flexible as the model evolves.</p>"},{"location":"faq/#is-it-about-less-strict-consistency","title":"Is it about less strict consistency?","text":"<p>No: while DCB allows to define very specific consistency boundaries, those are always enforced immediately.</p>"},{"location":"faq/#does-it-promote-using-strong-consistency-everywhere","title":"Does it promote using strong consistency everywhere?","text":"<p>No. DCB makes it easier to switch between the consistency models, but it is still important to think about strong vs eventual consistency and their implications to the behavior of the system.</p>"},{"location":"faq/#why-do-you-want-to-kill-aggregates","title":"Why do you want to kill Aggregates?","text":"<p>The idea of DCB started with the goal of killing the Aggregate .</p> <p>However, DCB does not actually attack the Aggregate pattern itself. Instead, it offers an alternative approach to achieving consistency in event-driven architectures \u2014 one that doesn't rely on Aggregates as the primary mechanism.</p> <p>For more on this, see our article on Aggregates.</p>"},{"location":"faq/#does-dcb-force-me-to-scatter-business-logic","title":"Does DCB force me to scatter business logic?","text":"<p>DCB enables you to structure code around use cases in order to focus on the behavior rather than the data models.</p> <p>However, DCB does not dictate how you design your application. You're free to organize logic around entities if that better suits your workflow.</p>"},{"location":"faq/#can-i-still-use-aggregates-with-dcb","title":"Can I still use Aggregates with DCB?","text":"<p>Yes, that\u2019s possible; the Event-Sourced Aggregate example demonstrates that.</p>"},{"location":"faq/#is-dcb-increasing-complexity","title":"Is DCB increasing complexity?","text":"<p>On the contrary. While DCB may challenge certain assumptions and require some adaptation, we believe it simplifies the overall mental model by allowing you to decide between strong and eventual consistency on a case-by-case basis.</p>"},{"location":"faq/#how-does-it-improve-performance","title":"How does it improve performance?","text":"<p>The primary goal of DCB is not to improve performance, but to provide a way to selectively enforce consistency where it\u2019s actually needed. That said, in large-scale applications, enforcing strict consistency everywhere can become a performance bottleneck. By making it easier to apply eventual consistency where appropriate, DCB can help systems scale more effectively and potentially improve performance as a side effect\u2014though that\u2019s not its core purpose.</p>"},{"location":"faq/#how-does-it-scale","title":"How does it scale?","text":"<p>DCB is still a relatively young concept, and its scalability characteristics are being actively explored. That said, early benchmarks using a PostgreSQL-based implementation indicate promising performance: even after processing 1 million Events, the system maintained a throughput of approximately 0.001 seconds per Event \u2014 equivalent to around 1,000 events per second. While these results are preliminary and implementation-dependent, they suggest that DCB can scale effectively in practice, especially when paired with well-optimized persistence layers and infrastructure.</p>"},{"location":"faq/#does-it-increase-chances-of-lock-collisions","title":"Does it increase chances of lock collisions?","text":"<p>A collision occurs when multiple processes attempt to modify the same data at nearly the same time, leading to contention over access. DCB actually reduces the risk of such collisions by narrowing the scope of consistency enforcement. Instead of locking entire entities or aggregates, DCB allows fine-grained boundaries that isolate only the parts of the system where consistency constraints must be enforced. As a result, multiple processes can safely modify the same entity \u2013 so long as their changes don\u2019t violate each other\u2019s consistency requirements \u2014 thereby reducing contention and improving concurrency.</p>"},{"location":"faq/#how-can-it-be-used-with-a-traditional-event-store","title":"How can it be used with a \"traditional\" Event Store?","text":"<p>A DCB-compliant Event Store offers features that are not typically found in traditional Event Stores (see specification). As a result, a traditional Event Store can't be used with DCB directly out of the box.</p> <p>However, we\u2019re experimenting with an adapter layer that allows traditional Event Stores to support DCB features by incorporating strategies like pessimistic locking to enforce consistency where needed. Stay tuned.</p>"},{"location":"faq/#nothing-comes-for-free-what-are-limitationsdrawbacks-of-dcb","title":"Nothing comes for free. What are limitations/drawbacks of DCB?","text":"<p>DCB guarantees consistency only inside the scope of the global Sequence Position. Thus, Events must be ordered to allow the conditional appending. As a result, it\u2019s not (easily) possible to partition Events. Furthermore, DCB leads to some additional complexity in the Event Store implementation (see Specification).</p>"},{"location":"faq/#what-are-the-next-steps","title":"What are the next steps?","text":"<p>The future of DCB is still unfolding. There\u2019s a lot more to discover, both conceptually and in practice and your feedback will play a key role in shaping its evolution \u2014 sparking new ideas, use cases, and conversations.</p> <p>We plan to continuously extend this website with more examples, articles, and resources to help others explore and apply DCB in real-world systems. Make sure to watch the Github Repository of this website to get notified about changes.</p>"},{"location":"specification/","title":"Specification","text":"<p>Note</p> <p>This document defines the minimal feature set an Event Store must provide to be DCB compliant.</p> <p>While we introduce certain concepts and terminology, implementations are not required to use the same terms or function/field names \u2014 as long as they offer equivalent functionality. (so <code>read()</code> could be <code>getEvents()</code> and <code>failIfEventsMatch</code> could be <code>referenceQuery</code> if those make more sense in your API)</p> <p>An Event Store that supports DCB provides a way to:</p> <ul> <li>read Sequenced Events matching a Query, optionally starting from a specified Sequence Position</li> <li>append Event(s), optionally specifying an Append Condition to enforce consistency</li> </ul>"},{"location":"specification/#reading-events","title":"Reading Events","text":"<p>The Event Store...</p> <ul> <li>... MUST provide a way to filter Events based on their Event Type and/or Tag (see Query)</li> <li>... SHOULD provide a way to read Events from a given starting Sequence Position</li> <li>... MAY provide further filter options, e.g. for ordering or to limit the number of Events to load at once </li> </ul> <p>A typical interface for reading events (pseudo-code):</p> <pre><code>EventStore {\n  read(query: Query, options?: ReadOptions): SequencedEvents\n  // ...\n}\n</code></pre> <p>Note: <code>SequencedEvents</code> represents some form of iterable or reactive stream of Sequenced Events</p>"},{"location":"specification/#writing-events","title":"Writing Events","text":"<p>The Event Store...</p> <ul> <li>... MUST provide a way to atomically persist one or more Event(s)</li> <li>... MUST fail if the Event Store contains at least one Event matching the Append Condition, if specified</li> </ul> <p>A typical interface for writing events (pseudo-code):</p> <pre><code>EventStore {\n  // ...\n  append(events: Events|Event, condition?: AppendCondition): void\n}\n</code></pre>"},{"location":"specification/#concepts","title":"Concepts","text":""},{"location":"specification/#query","title":"Query","text":"<p>The <code>Query</code> describes constraints that must be matched by Events in the Event Store. It effectively allows for filtering Events by their Type and/or Tags.</p> <ul> <li>It MUST contain a set of Query Items with at least one item or represent a query that matches all Events</li> <li>All Query Items are effectively combined with an OR, e.g. adding an extra Query Item will likely result in more Events being returned</li> </ul> <p>To differentiate the two query variants, dedicated factory methods might be helpful:</p> <pre><code>Query.fromItems(items)\nQuery.all()\n</code></pre>"},{"location":"specification/#query-item","title":"Query Item","text":"<p>Each item of a Query allows to target Events by their Type and/or Tags.</p> <p>An Event, to match a specific Query Item, needs to have the following characteristics:</p> <ul> <li>the Type MUST match one of the provided Types of the Query Item</li> <li>the Tags MUST contain all of the Tags specified by the Query Item</li> </ul>"},{"location":"specification/#example","title":"Example","text":"<p>The following example query would match Events that are either...</p> <ul> <li>...of type <code>EventType1</code> OR <code>EventType2</code></li> <li>...tagged <code>tag1</code> AND <code>tag2</code></li> <li>...of type <code>EventType2</code> OR <code>EventType3</code> AND tagged <code>tag1</code>AND <code>tag3</code></li> </ul> <pre><code>{\n  \"items\": [\n    {\n      \"types\": [\"EventType1\", \"EventType2\"]\n    },\n    {\n      \"tags\": [\"tag1\", \"tag2\"]\n    },\n    {\n      \"types\": [\"EventType2\", \"EventType3\"],\n      \"tags\": [\"tag1\", \"tag3\"]\n    }\n  ]\n}\n</code></pre>"},{"location":"specification/#sequenced-event","title":"Sequenced Event","text":"<p>Contains or embeds all information of the original <code>Event</code> and its Sequence Position that was added during the <code>append()</code> call.</p> <ul> <li>It MUST contain the Sequence Position</li> <li>It MUST contain the Event</li> <li>It MAY contain further fields, like metadata defined by the Event Store</li> </ul>"},{"location":"specification/#example_1","title":"Example","text":"<p>The following example shows a potential JSON representation of a Sequenced Event:</p> <pre><code>{\n  \"event\": {\n    ...\n  },\n  \"position\": 1234,\n  ...\n}\n</code></pre>"},{"location":"specification/#sequence-position","title":"Sequence Position","text":"<p>When an Event is appended, the Event Store assigns a <code>Sequence Position</code> to it.</p> <p>It...</p> <ul> <li>MUST be unique in the Event Store</li> <li>MUST be monotonic increasing</li> <li>MAY contain gaps</li> </ul>"},{"location":"specification/#events","title":"Events","text":"<p>A set of Event instances that is passed to the <code>append()</code> method of the Event Store</p> <p>It...</p> <ul> <li>MUST not be empty</li> <li>MUST be iterable, each iteration returning an Event</li> </ul>"},{"location":"specification/#event","title":"Event","text":"<ul> <li>It MUST contain an Event Type</li> <li>It MUST contain Event Data</li> <li>It MAY contain Tags</li> <li>It MAY contain further fields, like metadata defined by the client</li> </ul>"},{"location":"specification/#example_2","title":"Example","text":"<p>A potential JSON representation of an Event:</p> <pre><code>{\n  \"type\": \"SomeEventType\",\n  \"data\": \"{\\\"some\\\":\\\"data\\\"}\",\n  \"tags\": [\"tag1\", \"tag2\"],\n   ...\n}\n</code></pre>"},{"location":"specification/#event-type","title":"Event Type","text":"<p>Type of the event used to filter Events in the Query.</p>"},{"location":"specification/#event-data","title":"Event Data","text":"<p>Opaque payload of an Event</p>"},{"location":"specification/#tags","title":"Tags","text":"<p>A set of Tags.</p> <ul> <li>It SHOULD not contain multiple Tags with the same value</li> </ul>"},{"location":"specification/#tag","title":"Tag","text":"<p>A <code>Tag</code> can add domain-specific metadata to an event, allowing for custom partitioning. Usually, a Tag represents a concept of the domain, e.g. the type and id of an entity like <code>product:p123</code></p> <ul> <li>It MAY represent a key/value pair such as <code>product:123</code> but that is irrelevant to the Event Store</li> </ul>"},{"location":"specification/#append-condition","title":"Append Condition","text":"<p>The Append Condition is used to enforce consistency, ensuring that between the time of building the Decision Model and appending the events, no new events were stored by another client that match the same query.</p> <ul> <li>It MUST contain a <code>failIfEventsMatch</code> Query</li> <li>It MAY contain an <code>after</code> Sequence Position</li> <li>this represents the highest position the client was aware of while building the Decision Model. The Event Store MUST ignore the Events before the specified position while checking the condition for appending events. Note: This number can be higher than the position of the last event matching the Query.</li> <li>when <code>after</code> is present, the <code>failIfEventsMatch</code> Query is typically the same Query that was used when building the Decision Model, which guarantees that the Decision Model is still the same when we append new events</li> <li>if omitted, no Events will be ignored, effectively failing if any Event matches the specified Query</li> </ul> <pre><code>AppendCondition {\n  failIfEventsMatch: Query\n  after?: SequencePosition\n}\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>The following sections demonstrate several of the numerous scenarios that can be simplified with DCB:</p> Note <p>Most of the examples don't interact with the Event Store directly, but use higher level abstractions that allow for focusing on the business logic while demonstrating the potential of DCB. See article about Projections for more details</p>"},{"location":"examples/#constraints-affecting-multiple-entities","title":"Constraints affecting multiple entities","text":"<p>The most popular use case for DCB is to enforce hard constraints that affect multiple domain entities/concepts since it was covered in the \"Killing the Aggregate\" blog post by Sara Pellegrini . The course subscriptions example illustrates that scenario.</p>"},{"location":"examples/#enforcing-global-uniqueness","title":"Enforcing global uniqueness","text":"<p>Enforcing globally unique values is one of the evergreen-topics of eventual consistent applications. The unique username example demonstrates how easy this is with DCB.</p>"},{"location":"examples/#consecutive-sequence","title":"Consecutive sequence","text":"<p>Creating a monotonic sequence without gaps is a common requirement, for example in invoice numbering.</p>"},{"location":"examples/#replacing-read-models","title":"Replacing Read Models","text":"<p>Due to the flexibility of DCB, it can sometimes replace entire Read Models, for example to validate Opt-In tokens or to guarantee that a product can be purchased for the displayed price.</p>"},{"location":"examples/#idempotency","title":"Idempotency","text":"<p>Double submission is a common problem. It can usually be worked around by creating IDs on the client side, but sometimes that's not an option. DCB allows to use a dedicated idempotency id in order to prevent record duplication.</p> <p>Tip</p> <p>We will add more examples over time, make sure to watch the Github Repository of this website to get notified about changes</p>"},{"location":"examples/course-subscriptions/","title":"Course subscription example","text":"<p>The following example showcases the imagined application from Sara Pellegrini's blog post \"Killing the Aggregate\" </p>"},{"location":"examples/course-subscriptions/#challenge","title":"Challenge","text":"<p>The goal is an application that allows students to subscribe to courses, with the following hard constraints:</p> <ul> <li>A course cannot accept more than N students</li> <li>N, the course capacity, can change at any time to any positive integer different from the current one</li> <li>The student cannot join more than 10 courses</li> </ul>"},{"location":"examples/course-subscriptions/#traditional-approaches","title":"Traditional approaches","text":"<p>The first and last constraints, in particular, make this example difficult to implement using traditional Event Sourcing, as they cause the <code>student subscribed to course</code> Event to impact two separate entities, each with its own constraints.</p> <p>There are several potential strategies to solve this without DCB:</p> <ul> <li> <p>Eventual consistency: Turn one of the invariants into a soft constraint, i.e. use the Read Model for verification and accept the fact that there might be overbooked courses and/or students with more than 10 subscriptions</p> <p> This is of course a potential solution, with or without DCB, but it falls outside the scope of these examples</p> </li> <li> <p>Larger Aggregate: Create an Aggregate that spans course and student subscriptions</p> <p> This is not a viable solution because it leads to huge Aggregates and restricts parallel bookings</p> </li> <li> <p>Reservation Pattern: Create an Aggregate for each, courses and students, enforcing their constraints and use a Saga to coordinate them</p> <p> This works, but it leads to a lot of complexity and potentially invalid states for a period of time</p> </li> </ul>"},{"location":"examples/course-subscriptions/#dcb-approach","title":"DCB approach","text":"<p>With DCB the challenge can be solved simply by adding a Tag for each, the affected course and student to the <code>student subscribed to course</code>:</p> <p></p>"},{"location":"examples/course-subscriptions/#feature-1-register-courses","title":"Feature 1: Register courses","text":"<p>The first implementation just allows to specify new courses and make sure that they have a unique id:</p> JavaScriptTypeScriptGWT (WIP) Info <p>This example uses composed projections to build Decision Models (explore library source code )</p> <p><pre><code>// event type definitions:\n\nfunction CourseDefined({ courseId, capacity }) {\n  return {\n    type: \"CourseDefined\",\n    data: { courseId, capacity },\n    tags: [`course:${courseId}`],\n  }\n}\n\n// projections for decision models:\n\nfunction CourseExistsProjection(courseId) {\n  return createProjection({\n    initialState: false,\n    handlers: {\n      CourseDefined: (state, event) =&gt; true,\n    },\n    tagFilter: [`course:${courseId}`],\n  })\n}\n\n// command handlers:\n\nclass Api {\n  eventStore\n  constructor(eventStore) {\n    this.eventStore = eventStore\n  }\n\n  defineCourse(command) {\n    const { state, appendCondition } = buildDecisionModel(this.eventStore, {\n      courseExists: CourseExistsProjection(command.courseId),\n    })\n    if (state.courseExists) {\n      throw new Error(`Course with id \"${command.courseId}\" already exists`)\n    }\n    this.eventStore.append(\n      CourseDefined({\n        courseId: command.courseId,\n        capacity: command.capacity,\n      }),\n      appendCondition\n    )\n  }\n}\n\n// test cases:\n\nconst eventStore = new InMemoryDcbEventStore()\nconst api = new Api(eventStore)\nrunTests(api, eventStore, [\n  {\n    description: \"Define course with existing id\",\n    given: {\n      events: [\n        CourseDefined({\"courseId\":\"c1\",\"capacity\":10}),\n      ],\n    },\n    when: {\n      command: {\n        type: \"defineCourse\",\n        data: {\"courseId\":\"c1\",\"capacity\":15},\n      }\n    },\n    then: {\n      expectedError: \"Course with id \\\"c1\\\" already exists\",\n    }\n  }, \n  {\n    description: \"Define course with new id\",\n    when: {\n      command: {\n        type: \"defineCourse\",\n        data: {\"courseId\":\"c1\",\"capacity\":15},\n      }\n    },\n    then: {\n      expectedEvent: CourseDefined({\"courseId\":\"c1\",\"capacity\":15}),\n    }\n  }, \n])\n</code></pre> </p> Info <p>This example uses composed projections to build Decision Models (explore library source code )</p> <pre><code>// event type definitions:\n\nfunction CourseDefined({\n  courseId,\n  capacity,\n} : {\n  courseId: string,\n  capacity: number,\n}) {\n  return {\n    type: \"CourseDefined\" as const,\n    data: { courseId, capacity },\n    tags: [`course:${courseId}`],\n  }\n}\n\ntype EventTypes = ReturnType&lt;typeof CourseDefined&gt;\n\n// projections for decision models:\n\nfunction CourseExistsProjection(courseId: string) {\n  return createProjection&lt;EventTypes, boolean&gt;({\n    initialState: false,\n    handlers: {\n      CourseDefined: (state, event) =&gt; true,\n    },\n    tagFilter: [`course:${courseId}`],\n  })\n}\n\n// command handlers:\n\nclass Api {\n  constructor(private eventStore: EventStore) {}\n\n  defineCourse(command: { courseId: string; capacity: number }) {\n    const { state, appendCondition } = buildDecisionModel(this.eventStore, {\n      courseExists: CourseExistsProjection(command.courseId),\n    })\n    if (state.courseExists) {\n      throw new Error(`Course with id \"${command.courseId}\" already exists`)\n    }\n    this.eventStore.append(\n      CourseDefined({\n        courseId: command.courseId,\n        capacity: command.capacity,\n      }),\n      appendCondition\n    )\n  }\n}\n</code></pre> Experimental: 3rd party library <p>These Given/When/Then scenarios are visualized using an unofficial, work-in-progress, library</p> <p></p>"},{"location":"examples/course-subscriptions/#feature-2-change-course-capacity","title":"Feature 2: Change course capacity","text":"<p>The second implementation extends the first by a <code>changeCourseCapacity</code> command that allows to change the maximum number of seats for a given course:</p> JavaScriptTypeScriptGWT (WIP) Info <p>This example uses composed projections to build Decision Models (explore library source code )</p> <p><pre><code>// event type definitions:\n\nfunction CourseDefined({ courseId, capacity }) {\n  return {\n    type: \"CourseDefined\",\n    data: { courseId, capacity },\n    tags: [`course:${courseId}`],\n  }\n}\n\nfunction CourseCapacityChanged({ courseId, newCapacity }) {\n  return {\n    type: \"CourseCapacityChanged\",\n    data: { courseId, newCapacity },\n    tags: [`course:${courseId}`],\n  }\n}\n\n// projections for decision models:\n\nfunction CourseExistsProjection(courseId) {\n  return createProjection({\n    initialState: false,\n    handlers: {\n      CourseDefined: (state, event) =&gt; true,\n    },\n    tagFilter: [`course:${courseId}`],\n  })\n}\n\nfunction CourseCapacityProjection(courseId) {\n  return createProjection({\n    initialState: 0,\n    handlers: {\n      CourseDefined: (state, event) =&gt; event.data.capacity,\n      CourseCapacityChanged: (state, event) =&gt; event.data.newCapacity,\n    },\n    tagFilter: [`course:${courseId}`],\n  })\n}\n\n// command handlers:\n\nclass Api {\n  eventStore\n  constructor(eventStore) {\n    this.eventStore = eventStore\n  }\n\n  defineCourse(command) {\n    const { state, appendCondition } = buildDecisionModel(this.eventStore, {\n      courseExists: CourseExistsProjection(command.courseId),\n    })\n    if (state.courseExists) {\n      throw new Error(`Course with id \"${command.courseId}\" already exists`)\n    }\n    this.eventStore.append(\n      CourseDefined({\n        courseId: command.courseId,\n        capacity: command.capacity,\n      }),\n      appendCondition\n    )\n  }\n\n  changeCourseCapacity(command) {\n    const { state, appendCondition } = buildDecisionModel(this.eventStore, {\n      courseExists: CourseExistsProjection(command.courseId),\n      courseCapacity: CourseCapacityProjection(command.courseId),\n    })\n    if (!state.courseExists) {\n      throw new Error(`Course \"${command.courseId}\" does not exist`)\n    }\n    if (state.courseCapacity === command.newCapacity) {\n      throw new Error(`New capacity ${command.newCapacity} is the same as the current capacity`)\n    }\n    this.eventStore.append(\n      CourseCapacityChanged({\n        courseId: command.courseId,\n        newCapacity: command.newCapacity,\n      }),\n      appendCondition\n    )\n  }\n}\n\n// test cases:\n\nconst eventStore = new InMemoryDcbEventStore()\nconst api = new Api(eventStore)\nrunTests(api, eventStore, [\n  {\n    description: \"Define course with existing id\",\n    given: {\n      events: [\n        CourseDefined({\"courseId\":\"c1\",\"capacity\":10}),\n      ],\n    },\n    when: {\n      command: {\n        type: \"defineCourse\",\n        data: {\"courseId\":\"c1\",\"capacity\":15},\n      }\n    },\n    then: {\n      expectedError: \"Course with id \\\"c1\\\" already exists\",\n    }\n  }, \n  {\n    description: \"Define course with new id\",\n    when: {\n      command: {\n        type: \"defineCourse\",\n        data: {\"courseId\":\"c1\",\"capacity\":15},\n      }\n    },\n    then: {\n      expectedEvent: CourseDefined({\"courseId\":\"c1\",\"capacity\":15}),\n    }\n  }, \n  {\n    description: \"Change capacity of a non-existing course\",\n    when: {\n      command: {\n        type: \"changeCourseCapacity\",\n        data: {\"courseId\":\"c0\",\"newCapacity\":15},\n      }\n    },\n    then: {\n      expectedError: \"Course \\\"c0\\\" does not exist\",\n    }\n  }, \n  {\n    description: \"Change capacity of a course to a new value\",\n    given: {\n      events: [\n        CourseDefined({\"courseId\":\"c1\",\"capacity\":12}),\n      ],\n    },\n    when: {\n      command: {\n        type: \"changeCourseCapacity\",\n        data: {\"courseId\":\"c1\",\"newCapacity\":15},\n      }\n    },\n    then: {\n      expectedEvent: CourseCapacityChanged({\"courseId\":\"c1\",\"newCapacity\":15}),\n    }\n  }, \n])\n</code></pre> </p> Info <p>This example uses composed projections to build Decision Models (explore library source code )</p> <pre><code>// event type definitions:\n\nfunction CourseDefined({\n  courseId,\n  capacity,\n} : {\n  courseId: string,\n  capacity: number,\n}) {\n  return {\n    type: \"CourseDefined\" as const,\n    data: { courseId, capacity },\n    tags: [`course:${courseId}`],\n  }\n}\n\nfunction CourseCapacityChanged({\n  courseId,\n  newCapacity,\n} : {\n  courseId: string,\n  newCapacity: number,\n}) {\n  return {\n    type: \"CourseCapacityChanged\" as const,\n    data: { courseId, newCapacity },\n    tags: [`course:${courseId}`],\n  }\n}\n\ntype EventTypes = ReturnType&lt;\n  | typeof CourseDefined,\n  | typeof CourseCapacityChanged,\n&gt;\n\n// projections for decision models:\n\nfunction CourseExistsProjection(courseId: string) {\n  return createProjection&lt;EventTypes, boolean&gt;({\n    initialState: false,\n    handlers: {\n      CourseDefined: (state, event) =&gt; true,\n    },\n    tagFilter: [`course:${courseId}`],\n  })\n}\n\nfunction CourseCapacityProjection(courseId: string) {\n  return createProjection&lt;EventTypes, number&gt;({\n    initialState: 0,\n    handlers: {\n      CourseDefined: (state, event) =&gt; event.data.capacity,\n      CourseCapacityChanged: (state, event) =&gt; event.data.newCapacity,\n    },\n    tagFilter: [`course:${courseId}`],\n  })\n}\n\n// command handlers:\n\nclass Api {\n  constructor(private eventStore: EventStore) {}\n\n  defineCourse(command: { courseId: string; capacity: number }) {\n    const { state, appendCondition } = buildDecisionModel(this.eventStore, {\n      courseExists: CourseExistsProjection(command.courseId),\n    })\n    if (state.courseExists) {\n      throw new Error(`Course with id \"${command.courseId}\" already exists`)\n    }\n    this.eventStore.append(\n      CourseDefined({\n        courseId: command.courseId,\n        capacity: command.capacity,\n      }),\n      appendCondition\n    )\n  }\n\n  changeCourseCapacity(command: { studentId: string; newCapacity: number }) {\n    const { state, appendCondition } = buildDecisionModel(this.eventStore, {\n      courseExists: CourseExistsProjection(command.courseId),\n      courseCapacity: CourseCapacityProjection(command.courseId),\n    })\n    if (!state.courseExists) {\n      throw new Error(`Course \"${command.courseId}\" does not exist`)\n    }\n    if (state.courseCapacity === command.newCapacity) {\n      throw new Error(`New capacity ${command.newCapacity} is the same as the current capacity`)\n    }\n    this.eventStore.append(\n      CourseCapacityChanged({\n        courseId: command.courseId,\n        newCapacity: command.newCapacity,\n      }),\n      appendCondition\n    )\n  }\n}\n</code></pre> Experimental: 3rd party library <p>These Given/When/Then scenarios are visualized using an unofficial, work-in-progress, library</p> <p></p>"},{"location":"examples/course-subscriptions/#feature-3-subscribe-student-to-course","title":"Feature 3: Subscribe student to course","text":"<p>The last implementation contains the core example that requires constraint checks across multiple entities, adding a <code>subscribeStudentToCourse</code> command with a corresponding handler that checks...</p> <ul> <li>...whether the course with the specified id exists</li> <li>...whether the specified course still has available seats</li> <li>...whether the student with the specified id is not yet subscribed to given course</li> <li>...whether the student is not subscribed to more than 5 courses already</li> </ul> JavaScriptTypeScriptGWT (WIP) Info <p>This example uses composed projections to build Decision Models (explore library source code )</p> <p><pre><code>// event type definitions:\n\nfunction CourseDefined({ courseId, capacity }) {\n  return {\n    type: \"CourseDefined\",\n    data: { courseId, capacity },\n    tags: [`course:${courseId}`],\n  }\n}\n\nfunction CourseCapacityChanged({ courseId, newCapacity }) {\n  return {\n    type: \"CourseCapacityChanged\",\n    data: { courseId, newCapacity },\n    tags: [`course:${courseId}`],\n  }\n}\n\nfunction StudentSubscribedToCourse({ studentId, courseId }) {\n  return {\n    type: \"StudentSubscribedToCourse\",\n    data: { studentId, courseId },\n    tags: [`student:${studentId}`, `course:${courseId}`],\n  }\n}\n\n// projections for decision models:\n\nfunction CourseExistsProjection(courseId) {\n  return createProjection({\n    initialState: false,\n    handlers: {\n      CourseDefined: (state, event) =&gt; true,\n    },\n    tagFilter: [`course:${courseId}`],\n  })\n}\n\nfunction CourseCapacityProjection(courseId) {\n  return createProjection({\n    initialState: 0,\n    handlers: {\n      CourseDefined: (state, event) =&gt; event.data.capacity,\n      CourseCapacityChanged: (state, event) =&gt; event.data.newCapacity,\n    },\n    tagFilter: [`course:${courseId}`],\n  })\n}\n\nfunction StudentAlreadySubscribedProjection(studentId, courseId) {\n  return createProjection({\n    initialState: false,\n    handlers: {\n      StudentSubscribedToCourse: (state, event) =&gt; true,\n    },\n    tagFilter: [`student:${studentId}`, `course:${courseId}`],\n  })\n}\n\nfunction NumberOfCourseSubscriptionsProjection(courseId) {\n  return createProjection({\n    initialState: 0,\n    handlers: {\n      StudentSubscribedToCourse: (state, event) =&gt; state + 1,\n    },\n    tagFilter: [`course:${courseId}`],\n  })\n}\n\nfunction NumberOfStudentSubscriptionsProjection(studentId) {\n  return createProjection({\n    initialState: 0,\n    handlers: {\n      StudentSubscribedToCourse: (state, event) =&gt; state + 1,\n    },\n    tagFilter: [`student:${studentId}`],\n  })\n}\n\n// command handlers:\n\nclass Api {\n  eventStore\n  constructor(eventStore) {\n    this.eventStore = eventStore\n  }\n\n  defineCourse(command) {\n    const { state, appendCondition } = buildDecisionModel(this.eventStore, {\n      courseExists: CourseExistsProjection(command.courseId),\n    })\n    if (state.courseExists) {\n      throw new Error(`Course with id \"${command.courseId}\" already exists`)\n    }\n    this.eventStore.append(\n      CourseDefined({\n        courseId: command.courseId,\n        capacity: command.capacity,\n      }),\n      appendCondition\n    )\n  }\n\n  changeCourseCapacity(command) {\n    const { state, appendCondition } = buildDecisionModel(this.eventStore, {\n      courseExists: CourseExistsProjection(command.courseId),\n      courseCapacity: CourseCapacityProjection(command.courseId),\n    })\n    if (!state.courseExists) {\n      throw new Error(`Course \"${command.courseId}\" does not exist`)\n    }\n    if (state.courseCapacity === command.newCapacity) {\n      throw new Error(`New capacity ${command.newCapacity} is the same as the current capacity`)\n    }\n    this.eventStore.append(\n      CourseCapacityChanged({\n        courseId: command.courseId,\n        newCapacity: command.newCapacity,\n      }),\n      appendCondition\n    )\n  }\n\n  subscribeStudentToCourse(command) {\n    const { state, appendCondition } = buildDecisionModel(this.eventStore, {\n      courseExists: CourseExistsProjection(command.courseId),\n      courseCapacity: CourseCapacityProjection(command.courseId),\n      numberOfCourseSubscriptions: NumberOfCourseSubscriptionsProjection(command.courseId),\n      numberOfStudentSubscriptions: NumberOfStudentSubscriptionsProjection(command.studentId),\n      studentAlreadySubscribed: StudentAlreadySubscribedProjection(command.studentId, command.courseId),\n    })\n    if (!state.courseExists) {\n      throw new Error(`Course \"${command.courseId}\" does not exist`)\n    }\n    if (state.numberOfCourseSubscriptions &gt;= state.courseCapacity) {\n      throw new Error(`Course \"${command.courseId}\" is already fully booked`)\n    }\n    if (state.studentAlreadySubscribed) {\n      throw new Error(\"Student already subscribed to this course\")\n    }\n    if (state.numberOfStudentSubscriptions &gt;= 5) {\n      throw new Error(\"Student already subscribed to 5 courses\")\n    }\n    this.eventStore.append(\n      StudentSubscribedToCourse({\n        studentId: command.studentId,\n        courseId: command.courseId,\n      }),\n      appendCondition\n    )\n  }\n}\n\n// test cases:\n\nconst eventStore = new InMemoryDcbEventStore()\nconst api = new Api(eventStore)\nrunTests(api, eventStore, [\n  {\n    description: \"Define course with existing id\",\n    given: {\n      events: [\n        CourseDefined({\"courseId\":\"c1\",\"capacity\":10}),\n      ],\n    },\n    when: {\n      command: {\n        type: \"defineCourse\",\n        data: {\"courseId\":\"c1\",\"capacity\":15},\n      }\n    },\n    then: {\n      expectedError: \"Course with id \\\"c1\\\" already exists\",\n    }\n  }, \n  {\n    description: \"Define course with new id\",\n    when: {\n      command: {\n        type: \"defineCourse\",\n        data: {\"courseId\":\"c1\",\"capacity\":15},\n      }\n    },\n    then: {\n      expectedEvent: CourseDefined({\"courseId\":\"c1\",\"capacity\":15}),\n    }\n  }, \n  {\n    description: \"Change capacity of a non-existing course\",\n    when: {\n      command: {\n        type: \"changeCourseCapacity\",\n        data: {\"courseId\":\"c0\",\"newCapacity\":15},\n      }\n    },\n    then: {\n      expectedError: \"Course \\\"c0\\\" does not exist\",\n    }\n  }, \n  {\n    description: \"Change capacity of a course to a new value\",\n    given: {\n      events: [\n        CourseDefined({\"courseId\":\"c1\",\"capacity\":12}),\n      ],\n    },\n    when: {\n      command: {\n        type: \"changeCourseCapacity\",\n        data: {\"courseId\":\"c1\",\"newCapacity\":15},\n      }\n    },\n    then: {\n      expectedEvent: CourseCapacityChanged({\"courseId\":\"c1\",\"newCapacity\":15}),\n    }\n  }, \n  {\n    description: \"Subscribe student to non-existing course\",\n    when: {\n      command: {\n        type: \"subscribeStudentToCourse\",\n        data: {\"studentId\":\"s1\",\"courseId\":\"c0\"},\n      }\n    },\n    then: {\n      expectedError: \"Course \\\"c0\\\" does not exist\",\n    }\n  }, \n  {\n    description: \"Subscribe student to fully booked course\",\n    given: {\n      events: [\n        CourseDefined({\"courseId\":\"c1\",\"capacity\":3}),\n        StudentSubscribedToCourse({\"studentId\":\"s1\",\"courseId\":\"c1\"}),\n        StudentSubscribedToCourse({\"studentId\":\"s2\",\"courseId\":\"c1\"}),\n        StudentSubscribedToCourse({\"studentId\":\"s3\",\"courseId\":\"c1\"}),\n      ],\n    },\n    when: {\n      command: {\n        type: \"subscribeStudentToCourse\",\n        data: {\"studentId\":\"s4\",\"courseId\":\"c1\"},\n      }\n    },\n    then: {\n      expectedError: \"Course \\\"c1\\\" is already fully booked\",\n    }\n  }, \n  {\n    description: \"Subscribe student to the same course twice\",\n    given: {\n      events: [\n        CourseDefined({\"courseId\":\"c1\",\"capacity\":10}),\n        StudentSubscribedToCourse({\"studentId\":\"s1\",\"courseId\":\"c1\"}),\n      ],\n    },\n    when: {\n      command: {\n        type: \"subscribeStudentToCourse\",\n        data: {\"studentId\":\"s1\",\"courseId\":\"c1\"},\n      }\n    },\n    then: {\n      expectedError: \"Student already subscribed to this course\",\n    }\n  }, \n  {\n    description: \"Subscribe student to more than 5 courses\",\n    given: {\n      events: [\n        CourseDefined({\"courseId\":\"c6\",\"capacity\":10}),\n        StudentSubscribedToCourse({\"studentId\":\"s1\",\"courseId\":\"c1\"}),\n        StudentSubscribedToCourse({\"studentId\":\"s1\",\"courseId\":\"c2\"}),\n        StudentSubscribedToCourse({\"studentId\":\"s1\",\"courseId\":\"c3\"}),\n        StudentSubscribedToCourse({\"studentId\":\"s1\",\"courseId\":\"c4\"}),\n        StudentSubscribedToCourse({\"studentId\":\"s1\",\"courseId\":\"c5\"}),\n      ],\n    },\n    when: {\n      command: {\n        type: \"subscribeStudentToCourse\",\n        data: {\"studentId\":\"s1\",\"courseId\":\"c6\"},\n      }\n    },\n    then: {\n      expectedError: \"Student already subscribed to 5 courses\",\n    }\n  }, \n  {\n    description: \"Subscribe student to course with capacity\",\n    given: {\n      events: [\n        CourseDefined({\"courseId\":\"c1\",\"capacity\":10}),\n      ],\n    },\n    when: {\n      command: {\n        type: \"subscribeStudentToCourse\",\n        data: {\"studentId\":\"s1\",\"courseId\":\"c1\"},\n      }\n    },\n    then: {\n      expectedEvent: StudentSubscribedToCourse({\"studentId\":\"s1\",\"courseId\":\"c1\"}),\n    }\n  }, \n])\n</code></pre> </p> Info <p>This example uses composed projections to build Decision Models (explore library source code )</p> <pre><code>// event type definitions:\n\nfunction CourseDefined({\n  courseId,\n  capacity,\n} : {\n  courseId: string,\n  capacity: number,\n}) {\n  return {\n    type: \"CourseDefined\" as const,\n    data: { courseId, capacity },\n    tags: [`course:${courseId}`],\n  }\n}\n\nfunction CourseCapacityChanged({\n  courseId,\n  newCapacity,\n} : {\n  courseId: string,\n  newCapacity: number,\n}) {\n  return {\n    type: \"CourseCapacityChanged\" as const,\n    data: { courseId, newCapacity },\n    tags: [`course:${courseId}`],\n  }\n}\n\nfunction StudentSubscribedToCourse({\n  studentId,\n  courseId,\n} : {\n  studentId: string,\n  courseId: string,\n}) {\n  return {\n    type: \"StudentSubscribedToCourse\" as const,\n    data: { studentId, courseId },\n    tags: [`student:${studentId}`, `course:${courseId}`],\n  }\n}\n\ntype EventTypes = ReturnType&lt;\n  | typeof CourseDefined,\n  | typeof CourseCapacityChanged,\n  | typeof StudentSubscribedToCourse,\n&gt;\n\n// projections for decision models:\n\nfunction CourseExistsProjection(courseId: string) {\n  return createProjection&lt;EventTypes, boolean&gt;({\n    initialState: false,\n    handlers: {\n      CourseDefined: (state, event) =&gt; true,\n    },\n    tagFilter: [`course:${courseId}`],\n  })\n}\n\nfunction CourseCapacityProjection(courseId: string) {\n  return createProjection&lt;EventTypes, number&gt;({\n    initialState: 0,\n    handlers: {\n      CourseDefined: (state, event) =&gt; event.data.capacity,\n      CourseCapacityChanged: (state, event) =&gt; event.data.newCapacity,\n    },\n    tagFilter: [`course:${courseId}`],\n  })\n}\n\nfunction StudentAlreadySubscribedProjection(studentId: string, courseId: string) {\n  return createProjection&lt;EventTypes, boolean&gt;({\n    initialState: false,\n    handlers: {\n      StudentSubscribedToCourse: (state, event) =&gt; true,\n    },\n    tagFilter: [`student:${studentId}`, `course:${courseId}`],\n  })\n}\n\nfunction NumberOfCourseSubscriptionsProjection(courseId: string) {\n  return createProjection&lt;EventTypes, number&gt;({\n    initialState: 0,\n    handlers: {\n      StudentSubscribedToCourse: (state, event) =&gt; state + 1,\n    },\n    tagFilter: [`course:${courseId}`],\n  })\n}\n\nfunction NumberOfStudentSubscriptionsProjection(studentId: string) {\n  return createProjection&lt;EventTypes, number&gt;({\n    initialState: 0,\n    handlers: {\n      StudentSubscribedToCourse: (state, event) =&gt; state + 1,\n    },\n    tagFilter: [`student:${studentId}`],\n  })\n}\n\n// command handlers:\n\nclass Api {\n  constructor(private eventStore: EventStore) {}\n\n  defineCourse(command: { courseId: string; capacity: number }) {\n    const { state, appendCondition } = buildDecisionModel(this.eventStore, {\n      courseExists: CourseExistsProjection(command.courseId),\n    })\n    if (state.courseExists) {\n      throw new Error(`Course with id \"${command.courseId}\" already exists`)\n    }\n    this.eventStore.append(\n      CourseDefined({\n        courseId: command.courseId,\n        capacity: command.capacity,\n      }),\n      appendCondition\n    )\n  }\n\n  changeCourseCapacity(command: { studentId: string; newCapacity: number }) {\n    const { state, appendCondition } = buildDecisionModel(this.eventStore, {\n      courseExists: CourseExistsProjection(command.courseId),\n      courseCapacity: CourseCapacityProjection(command.courseId),\n    })\n    if (!state.courseExists) {\n      throw new Error(`Course \"${command.courseId}\" does not exist`)\n    }\n    if (state.courseCapacity === command.newCapacity) {\n      throw new Error(`New capacity ${command.newCapacity} is the same as the current capacity`)\n    }\n    this.eventStore.append(\n      CourseCapacityChanged({\n        courseId: command.courseId,\n        newCapacity: command.newCapacity,\n      }),\n      appendCondition\n    )\n  }\n\n  subscribeStudentToCourse(command: { studentId: string; courseId: string }) {\n    const { state, appendCondition } = buildDecisionModel(this.eventStore, {\n      courseExists: CourseExistsProjection(command.courseId),\n      courseCapacity: CourseCapacityProjection(command.courseId),\n      numberOfCourseSubscriptions: NumberOfCourseSubscriptionsProjection(command.courseId),\n      numberOfStudentSubscriptions: NumberOfStudentSubscriptionsProjection(command.studentId),\n      studentAlreadySubscribed: StudentAlreadySubscribedProjection(command.studentId, command.courseId),\n    })\n    if (!state.courseExists) {\n      throw new Error(`Course \"${command.courseId}\" does not exist`)\n    }\n    if (state.numberOfCourseSubscriptions &gt;= state.courseCapacity) {\n      throw new Error(`Course \"${command.courseId}\" is already fully booked`)\n    }\n    if (state.studentAlreadySubscribed) {\n      throw new Error(\"Student already subscribed to this course\")\n    }\n    if (state.numberOfStudentSubscriptions &gt;= 5) {\n      throw new Error(\"Student already subscribed to 5 courses\")\n    }\n    this.eventStore.append(\n      StudentSubscribedToCourse({\n        studentId: command.studentId,\n        courseId: command.courseId,\n      }),\n      appendCondition\n    )\n  }\n}\n</code></pre> Experimental: 3rd party library <p>These Given/When/Then scenarios are visualized using an unofficial, work-in-progress, library</p> <p></p>"},{"location":"examples/course-subscriptions/#other-implementations","title":"Other implementations","text":"<p>There is a working <code>JavaScript/TypeScript</code> and <code>PHP</code> implementation of this example</p>"},{"location":"examples/course-subscriptions/#conclusion","title":"Conclusion","text":"<p>The course subscription example demonstrates a typical requirement to enforce consistency that affects multiple entities that are not part of the same Aggregate. This document demonstrates how easy it is to achieve that with DCB</p>"},{"location":"examples/dynamic-product-price/","title":"Dynamic product price validation","text":"<p>The following example showcases a simple application that allows to purchase products, with a twist</p>"},{"location":"examples/dynamic-product-price/#challenge","title":"Challenge","text":"<p>The goal is an application that allows customers to purchase products, ensuring that the displayed price is taken into account \u2013 if it is valid:</p> <ul> <li>The product prices that are shown to the customer must be used for processing the order</li> <li>If a displayed product price is not/no longer valid, the order must fail</li> <li>Product prices can be changed at any time</li> <li>If a product price was changed, the previous price(s) must be valid for a configurable grace period</li> </ul>"},{"location":"examples/dynamic-product-price/#traditional-approaches","title":"Traditional approaches","text":"<p>There are several potential strategies to solve this without DCB:</p> <ul> <li> <p>Aggregate Pattern: For the single product use case an Aggregates could be used</p> <p> That only works if product change and -purchase Events are stored in the same Event Stream, which is unlikely to be a good idea</p> </li> <li> <p>Eventual consistency: Use the Read Model to verify the prices in the command handler</p> <p> That works, but the last requirement (changing prices) forces the model to keep track of historic data even though there might be no (other) use case for it to be kept. A separate, dedicated, model could be created of course but that adds complexity</p> </li> </ul>"},{"location":"examples/dynamic-product-price/#dcb-approach","title":"DCB approach","text":"<p>With DCB the challenge can be solved without any specific Tags (except for the <code>product:&lt;id&gt;</code> tag):</p>"},{"location":"examples/dynamic-product-price/#feature-1-order-single-product","title":"Feature 1: Order single product","text":"<p>If only a single product with a fixed price can be purchased at a time, the implementation is pretty simple:</p> <p></p> <pre><code>// event type definitions:\n\nfunction ProductDefined({ productId, price }) {\n  return {\n    type: \"ProductDefined\",\n    data: { productId, price },\n    tags: [`product:${productId}`],\n  }\n}\n\nfunction ProductOrdered({ productId, price }) {\n  return {\n    type: \"ProductOrdered\",\n    data: { productId, price },\n    tags: [`product:${productId}`],\n  }\n}\n\n// projections for decision models:\n\nfunction ProductPriceProjection(productId) {\n  return createProjection({\n    initialState: 0,\n    handlers: {\n      ProductDefined: (state, event) =&gt; event.data.price,\n    },\n    tags: [`product:${productId}`],\n  })\n}\n\n// command handlers:\n\nclass Api {\n  eventStore\n  constructor(eventStore) {\n    this.eventStore = eventStore\n  }\n\n  orderProduct(command) {\n    const { state, appendCondition } = buildDecisionModel(this.eventStore, {\n      productPrice: ProductPriceProjection(command.productId),\n    })\n    if (state.productPrice !== command.displayedPrice) {\n      throw new Error(`invalid price for product \"${command.productId}\"`)\n    }\n    this.eventStore.append(\n      ProductOrdered({\n        productId: command.productId,\n        price: command.displayedPrice,\n      }),\n      appendCondition\n    )\n  }\n}\n\n// test cases:\n\nconst eventStore = new InMemoryDcbEventStore()\nconst api = new Api(eventStore)\nrunTests(api, eventStore, [\n  {\n    description: \"Order product with invalid displayed price\",\n    given: {\n      events: [ProductDefined({ productId: \"p1\", price: 123 })],\n    },\n    when: {\n      command: {\n        type: \"orderProduct\",\n        data: { productId: \"p1\", displayedPrice: 100 },\n      },\n    },\n    then: {\n      expectedError: 'invalid price for product \"p1\"',\n    },\n  },\n  {\n    description: \"Order product with valid displayed price\",\n    given: {\n      events: [ProductDefined({ productId: \"p1\", price: 123 })],\n    },\n    when: {\n      command: {\n        type: \"orderProduct\",\n        data: { productId: \"p1\", displayedPrice: 123 },\n      },\n    },\n    then: {\n      expectedEvent: ProductOrdered({ productId: \"p1\", price: 123 }),\n    },\n  },\n])\n</code></pre> <p></p>"},{"location":"examples/dynamic-product-price/#feature-2-changing-product-prices","title":"Feature 2: Changing product prices","text":"<p>Complexity increases if the product price can be changed and previous prices shall be valid for a specified amount of time:</p> <p></p> <p>Note</p> <p>The <code>minutesAgo</code> property of the Event metadata is a simplification. Typically, a timestamp representing the Event's recording time is stored within the Event's payload or metadata. This timestamp can be compared to the current date to determine the Event's age in the decision model.</p> <pre><code>// event type definitions:\n\nfunction ProductDefined({ productId, price }) {\n  return {\n    type: \"ProductDefined\",\n    data: { productId, price },\n    tags: [`product:${productId}`],\n  }\n}\n\nfunction ProductPriceChanged({ productId, newPrice }) {\n  return {\n    type: \"ProductPriceChanged\",\n    data: { productId, newPrice },\n    tags: [`product:${productId}`],\n  }\n}\n\nfunction ProductOrdered({ productId, price }) {\n  return {\n    type: \"ProductOrdered\",\n    data: { productId, price },\n    tags: [`product:${productId}`],\n  }\n}\n\n// projections for decision models:\n\nfunction ProductPriceProjection(productId) {\n  const productPriceGracePeriod = 10 // minutes\n  return createProjection({\n    initialState: { lastValidOldPrice: null, validNewPrices: [] },\n    handlers: {\n      ProductDefined: (state, event) =&gt;\n        event.metadata?.minutesAgo &lt;= productPriceGracePeriod\n          ? { lastValidOldPrice: null, validNewPrices: [event.data.price] }\n          : { lastValidOldPrice: event.data.price, validNewPrices: [] },\n      ProductPriceChanged: (state, event) =&gt;\n        event.metadata?.minutesAgo &lt;= productPriceGracePeriod\n          ? {\n              lastValidOldPrice: state.lastValidOldPrice,\n              validNewPrices: [...state.validNewPrices, event.data.newPrice],\n            }\n          : {\n              lastValidOldPrice: event.data.newPrice,\n              validNewPrices: state.validNewPrices,\n            },\n    },\n    tagFilter: [`product:${productId}`],\n  })\n}\n\n// command handlers:\n\nclass Api {\n  eventStore\n  constructor(eventStore) {\n    this.eventStore = eventStore\n  }\n\n  orderProduct(command) {\n    const { state, appendCondition } = buildDecisionModel(this.eventStore, {\n      productPrice: ProductPriceProjection(command.productId),\n    })\n    if (\n      state.productPrice.lastValidOldPrice !== command.displayedPrice &amp;&amp;\n      !state.productPrice.validNewPrices.includes(command.displayedPrice)\n    ) {\n      throw new Error(`invalid price for product \"${command.productId}\"`)\n    }\n    this.eventStore.append(\n      ProductOrdered({\n        productId: command.productId,\n        price: command.displayedPrice,\n      }),\n      appendCondition\n    )\n  }\n}\n\n// test cases:\n\nconst eventStore = new InMemoryDcbEventStore()\nconst api = new Api(eventStore)\n\nrunTests(api, eventStore, [\n  {\n    description: \"Order product with invalid displayed price\",\n    given: {\n      events: [ProductDefined({ productId: \"p1\", price: 123 })],\n    },\n    when: {\n      command: {\n        type: \"orderProduct\",\n        data: { productId: \"p1\", displayedPrice: 100 },\n      },\n    },\n    then: {\n      expectedError: 'invalid price for product \"p1\"',\n    },\n  },\n  {\n    description: \"Order product with valid displayed price\",\n    given: {\n      events: [ProductDefined({ productId: \"p1\", price: 123 })],\n    },\n    when: {\n      command: {\n        type: \"orderProduct\",\n        data: { productId: \"p1\", displayedPrice: 123 },\n      },\n    },\n    then: {\n      expectedEvent: ProductOrdered({ productId: \"p1\", price: 123 }),\n    },\n  },\n  {\n    description: \"Order product with a displayed price that was never valid\",\n    given: {\n      events: [\n        addEventMetadata(ProductDefined({ productId: \"p1\", price: 123 }), {\n          minutesAgo: 20,\n        }),\n      ],\n    },\n    when: {\n      command: {\n        type: \"orderProduct\",\n        data: { productId: \"p1\", displayedPrice: 100 },\n      },\n    },\n    then: {\n      expectedError: 'invalid price for product \"p1\"',\n    },\n  },\n  {\n    description:\n      \"Order product with a price that was changed more than 10 minutes ago\",\n    given: {\n      events: [\n        addEventMetadata(ProductDefined({ productId: \"p1\", price: 123 }), {\n          minutesAgo: 20,\n        }),\n        addEventMetadata(\n          ProductPriceChanged({ productId: \"p1\", newPrice: 134 }),\n          {\n            minutesAgo: 20,\n          }\n        ),\n      ],\n    },\n    when: {\n      command: {\n        type: \"orderProduct\",\n        data: { productId: \"p1\", displayedPrice: 123 },\n      },\n    },\n    then: {\n      expectedError: 'invalid price for product \"p1\"',\n    },\n  },\n  {\n    description: \"Order product with initial valid price\",\n    given: {\n      events: [\n        addEventMetadata(ProductDefined({ productId: \"p1\", price: 123 }), {\n          minutesAgo: 20,\n        }),\n      ],\n    },\n    when: {\n      command: {\n        type: \"orderProduct\",\n        data: { productId: \"p1\", displayedPrice: 123 },\n      },\n    },\n    then: {\n      expectedEvent: ProductOrdered({\n        productId: \"p1\",\n        price: 123,\n      }),\n    },\n  },\n  {\n    description:\n      \"Order product with a price that was changed less than 10 minutes ago\",\n    given: {\n      events: [\n        addEventMetadata(ProductDefined({ productId: \"p1\", price: 123 }), {\n          minutesAgo: 20,\n        }),\n        addEventMetadata(\n          ProductPriceChanged({ productId: \"p1\", newPrice: 134 }),\n          {\n            minutesAgo: 9,\n          }\n        ),\n      ],\n    },\n    when: {\n      command: {\n        type: \"orderProduct\",\n        data: { productId: \"p1\", displayedPrice: 123 },\n      },\n    },\n    then: {\n      expectedEvent: ProductOrdered({\n        productId: \"p1\",\n        price: 123,\n      }),\n    },\n  },\n  {\n    description: \"Order product with valid new price\",\n    given: {\n      events: [\n        addEventMetadata(ProductDefined({ productId: \"p1\", price: 123 }), {\n          minutesAgo: 20,\n        }),\n        addEventMetadata(\n          ProductPriceChanged({ productId: \"p1\", newPrice: 134 }),\n          {\n            minutesAgo: 9,\n          }\n        ),\n      ],\n    },\n    when: {\n      command: {\n        type: \"orderProduct\",\n        data: { productId: \"p1\", displayedPrice: 134 },\n      },\n    },\n    then: {\n      expectedEvent: ProductOrdered({\n        productId: \"p1\",\n        price: 134,\n      }),\n    },\n  },\n])\n</code></pre> <p></p>"},{"location":"examples/dynamic-product-price/#feature-3-multiple-products-shopping-cart","title":"Feature 3: Multiple products (shopping cart)","text":"<p>The previous stages could be implemented with a traditional Event-Sourced Aggregate in theory. But with the requirement to be able to order multiple products at once with a dynamic price, the flexibility of DCB shines:</p> <pre><code>// event type definitions:\n\nfunction ProductDefined({ productId, price }) {\n  return {\n    type: \"ProductDefined\",\n    data: { productId, price },\n    tags: [`product:${productId}`],\n  }\n}\n\nfunction ProductPriceChanged({ productId, newPrice }) {\n  return {\n    type: \"ProductPriceChanged\",\n    data: { productId, newPrice },\n    tags: [`product:${productId}`],\n  }\n}\n\nfunction ProductsOrdered({ items }) {\n  return {\n    type: \"ProductsOrdered\",\n    data: { items },\n    tags: items.map((item) =&gt; `product:${item.productId}`),\n  }\n}\n\n// projections for decision models:\n\nfunction ProductPriceProjection(productId) {\n  const productPriceGracePeriod = 10 // minutes\n  return createProjection({\n    initialState: { lastValidOldPrice: null, validNewPrices: [] },\n    handlers: {\n      ProductDefined: (state, event) =&gt;\n        event.metadata.minutesAgo &lt;= productPriceGracePeriod\n          ? { lastValidOldPrice: null, validNewPrices: [event.data.price] }\n          : { lastValidOldPrice: event.data.price, validNewPrices: [] },\n      ProductPriceChanged: (state, event) =&gt;\n        event.metadata.minutesAgo &lt;= productPriceGracePeriod\n          ? {\n              lastValidOldPrice: state.lastValidOldPrice,\n              validNewPrices: [...state.validNewPrices, event.data.newPrice],\n            }\n          : {\n              lastValidOldPrice: event.data.newPrice,\n              validNewPrices: state.validNewPrices,\n            },\n    },\n    tagFilter: [`product:${productId}`],\n  })\n}\n\n// command handlers:\n\nclass Api {\n  eventStore\n  constructor(eventStore) {\n    this.eventStore = eventStore\n  }\n\n  orderProducts(command) {\n    const { state, appendCondition } = buildDecisionModel(\n      this.eventStore,\n      command.items.reduce((models, item) =&gt; {\n        models[item.productId] = ProductPriceProjection(item.productId)\n        return models\n      }, {})\n    )\n    for (const item of command.items) {\n      if (\n        state[item.productId].lastValidOldPrice !== item.displayedPrice &amp;&amp;\n        !state[item.productId].validNewPrices.includes(item.displayedPrice)\n      ) {\n        throw new Error(`invalid price for product \"${item.productId}\"`)\n      }\n    }\n\n    this.eventStore.append(\n      ProductsOrdered({\n        items: command.items.map((item) =&gt; ({\n          productId: item.productId,\n          price: item.displayedPrice,\n        })),\n      }),\n      appendCondition\n    )\n  }\n}\n\n// test cases:\n\nconst eventStore = new InMemoryDcbEventStore()\nconst api = new Api(eventStore)\n\nrunTests(api, eventStore, [\n  {\n    description: \"Order product with a displayed price that was never valid\",\n    given: {\n      events: [\n        addEventMetadata(ProductDefined({ productId: \"p1\", price: 123 }), {\n          minutesAgo: 20,\n        }),\n      ],\n    },\n    when: {\n      command: {\n        type: \"orderProducts\",\n        data: { items: [{ productId: \"p1\", displayedPrice: 100 }] },\n      },\n    },\n    then: {\n      expectedError: 'invalid price for product \"p1\"',\n    },\n  },\n  {\n    description:\n      \"Order product with a price that was changed more than 10 minutes ago\",\n    given: {\n      events: [\n        addEventMetadata(ProductDefined({ productId: \"p1\", price: 123 }), {\n          minutesAgo: 20,\n        }),\n        addEventMetadata(\n          ProductPriceChanged({ productId: \"p1\", newPrice: 134 }),\n          {\n            minutesAgo: 20,\n          }\n        ),\n      ],\n    },\n    when: {\n      command: {\n        type: \"orderProducts\",\n        data: { items: [{ productId: \"p1\", displayedPrice: 123 }] },\n      },\n    },\n    then: {\n      expectedError: 'invalid price for product \"p1\"',\n    },\n  },\n  {\n    description: \"Order product with initial valid price\",\n    given: {\n      events: [\n        addEventMetadata(ProductDefined({ productId: \"p1\", price: 123 }), {\n          minutesAgo: 20,\n        }),\n      ],\n    },\n    when: {\n      command: {\n        type: \"orderProducts\",\n        data: { items: [{ productId: \"p1\", displayedPrice: 123 }] },\n      },\n    },\n    then: {\n      expectedEvent: ProductsOrdered({\n        items: [\n          {\n            productId: \"p1\",\n            price: 123,\n          },\n        ],\n      }),\n    },\n  },\n  {\n    description:\n      \"Order product with a price that was changed less than 10 minutes ago\",\n    given: {\n      events: [\n        addEventMetadata(ProductDefined({ productId: \"p1\", price: 123 }), {\n          minutesAgo: 20,\n        }),\n        addEventMetadata(\n          ProductPriceChanged({ productId: \"p1\", newPrice: 134 }),\n          {\n            minutesAgo: 9,\n          }\n        ),\n      ],\n    },\n    when: {\n      command: {\n        type: \"orderProducts\",\n        data: { items: [{ productId: \"p1\", displayedPrice: 123 }] },\n      },\n    },\n    then: {\n      expectedEvent: ProductsOrdered({\n        items: [\n          {\n            productId: \"p1\",\n            price: 123,\n          },\n        ],\n      }),\n    },\n  },\n  {\n    description: \"Order multiple products with valid prices\",\n    given: {\n      events: [\n        addEventMetadata(ProductDefined({ productId: \"p1\", price: 123 }), {\n          minutesAgo: 20,\n        }),\n        addEventMetadata(\n          ProductPriceChanged({ productId: \"p1\", newPrice: 134 }),\n          {\n            minutesAgo: 9,\n          }\n        ),\n        addEventMetadata(ProductDefined({ productId: \"p2\", price: 321 }), {\n          minutesAgo: 8,\n        }),\n      ],\n    },\n    when: {\n      command: {\n        type: \"orderProducts\",\n        data: {\n          items: [\n            { productId: \"p1\", displayedPrice: 123 },\n            { productId: \"p2\", displayedPrice: 321 },\n          ],\n        },\n      },\n    },\n    then: {\n      expectedEvent: ProductsOrdered({\n        items: [\n          {\n            productId: \"p1\",\n            price: 123,\n          },\n          {\n            productId: \"p2\",\n            price: 321,\n          },\n        ],\n      }),\n    },\n  },\n])\n</code></pre> <p></p>"},{"location":"examples/dynamic-product-price/#conclusion","title":"Conclusion","text":"<p>This example demonstrates the possibility to enforce consistency for a very dynamic set of entities</p>"},{"location":"examples/event-sourced-aggregate/","title":"Event-Sourced Aggregate","text":"<p>With DCB there are more flexible ways to enforce consistency (see article about Aggregates).</p> <p>Sometimes, however, an Event-Sourced Aggregate can still be useful. For example to slowly migrate an existing Event-Sourced application or if the flexibility of DCB is not required (see conclusion below)</p>"},{"location":"examples/event-sourced-aggregate/#challenge","title":"Challenge","text":"<p>The goal is to implement an Event-Sourced Aggregate that works with a DCB compliant Event Store</p>"},{"location":"examples/event-sourced-aggregate/#traditional-approaches","title":"Traditional approaches","text":"<p>The Implementation of an Event-Sourced Aggregate depends on the Programming Language and Framework, but the common functionality is:</p> <ol> <li>Relevant Events are loaded, remembering the position of the last consumed Event</li> <li>A decision is made based on the projected state of those Events</li> <li>If successful, a new Event is appended specifying the remembered position</li> <li>The Event Store appends the new Event only if no other Event was stored in the meantime and fails otherwise</li> <li>Upon failure the process can be repeated until the Event was successfully persisted</li> </ol> <p>The following is a potential JavaScript version of an Aggregate representing a course students can be subscribed to:</p> CourseAggregate.js<pre><code>/**\n * @typedef {{type: string}} Event\n * @typedef {{position: number, type: string}} SequencedEvent\n */\nclass CourseAggregate {\n  /**\n   * @type {Event[]} Every state change is stored as a corresponding Event\n   */\n  #recordedEvents = []\n\n  /**\n   * @type {number} The version of this Aggregate at the time of reconstitution\n   */\n  #version = 0\n\n  /** @type {string} Identifier of the course */\n  #id\n  #capacity = 0\n  #numberOfSubscriptions = 0\n\n  /**\n   * Static constructor that returns a new CourseAggregate instance\n   *\n   * @param {string} id\n   * @param {string} title\n   * @param {number} capacity\n   * @returns {CourseAggregate}\n   */\n  static create(id, title, capacity) {\n    const instance = new CourseAggregate()\n    instance.#recordEvent({\n      type: \"CourseDefined\",\n      data: { courseId: id, title, capacity },\n    })\n    return instance\n  }\n\n  /**\n   * Static constructor that returns an existing CourseAggregate instance\n   * from previously persisted events\n   *\n   * @param {SequencedEvent[]} sequencedEvents\n   * @returns {CourseAggregate}\n   */\n  static reconstitute(sequencedEvents) {\n    const instance = new CourseAggregate()\n    for (const event of sequencedEvents) {\n      instance.#apply(event)\n      instance.#version = event.position\n    }\n    return instance\n  }\n\n  /**\n   * @returns {string} The identifier of this Aggregate\n   */\n  get id() {\n    return this.#id\n  }\n\n  /**\n   * @returns {number} The version of this Aggregate (for optimistic locking)\n   */\n  get version() {\n    return this.#version\n  }\n\n  /**\n   * API to change the course's capacity\n   * @param {number} newCapacity\n   * @returns {void}\n   */\n  changeCapacity(newCapacity) {\n    if (newCapacity === this.#capacity) {\n      throw new Error(\n        `Course \"${this.#id}\" already has a capacity of \"${newCapacity}`\n      )\n    }\n    if (newCapacity &lt; this.#numberOfSubscriptions) {\n      throw new Error(\n        `Course \"${this.#id}\" already has ${\n          this.#numberOfSubscriptions\n        } active subscriptions, can\\'t set the capacity below that`\n      )\n    }\n    this.#recordEvent({\n      type: \"CourseCapacityChanged\",\n      data: { courseId: this.#id, newCapacity },\n    })\n  }\n\n  /**\n   * API to subscribe a student to this course\n   * @param {string} studentId Identifier of the student to subscribe\n   * @returns {void}\n   */\n  subscribeStudent(studentId) {\n    if (this.#numberOfSubscriptions === this.#capacity) {\n      throw new Error(`Course \"${this.#id}\" is already fully booked`)\n    }\n    this.#recordEvent({\n      type: \"StudentSubscribedToCourse\",\n      data: { courseId: this.#id, studentId },\n    })\n  }\n\n  /**\n   * Internal method to store an event and apply it to the in-memory state\n   * @param {Event} event\n   */\n  #recordEvent(event) {\n    this.#recordedEvents.push(event)\n    this.#apply(event)\n  }\n\n  /**\n   * Internal method to apply an event to the in-memory state of this Aggregate\n   * @param {Event} event\n   */\n  #apply(event) {\n    switch (event.type) {\n      case \"CourseDefined\":\n        this.#id = event.data.courseId\n        this.#capacity = event.data.capacity\n        break\n      case \"CourseCapacityChanged\":\n        this.#capacity = event.data.newCapacity\n        break\n      case \"StudentSubscribedToCourse\":\n        this.#numberOfSubscriptions++\n        break\n    }\n  }\n\n  /**\n   * Public method to retrieve and flush all recorded events\n   * @returns {Event[]}\n   */\n  pullRecordedEvents() {\n    const recordedEvents = this.#recordedEvents\n    this.#recordedEvents = []\n    return recordedEvents\n  }\n}\n</code></pre> <p></p> <p>With that, a <code>CourseAggregate</code> can be created:</p> <pre><code>const course = CourseAggregate.create('c1', 'Course 01', 10)\ncourse.changeCapacity(15)\nconst events = course.pullRecordedEvents()\nconsole.log(events.map(e =&gt; e.type)) // [\"CourseDefined\",\"CourseCapacityChanged\"]\n</code></pre> <p></p> <p>...or reconstituted from previously recorded events:</p> <pre><code>const events = [\n  {\n    position: 1,\n    type: \"CourseDefined\",\n    data: { courseId: \"c1\", title: \"Course 01\", capacity: 10 },\n    tags: [\"course:c1\"],\n  },\n  {\n    position: 2,\n    type: \"CourseCapacityChanged\",\n    data: { courseId: \"c1\", newCapacity: 15 },\n    tags: [\"course:c1\"],\n  },\n]\nconst course = CourseAggregate.reconstitute(events)\ncourse.changeCapacity(15) // Error: Course \"c1\" already has a capacity of \"15\n</code></pre> <p></p>"},{"location":"examples/event-sourced-aggregate/#repository","title":"Repository","text":"<p>Aggregates are often paired with a corresponding Repository that handles saving and retrieving instances.</p> <p>The following shows a simple implementation that works with a traditional Event Store:</p> CourseRepository.js<pre><code>class CourseRepository {\n  #eventStore\n  constructor(eventStore) {\n    this.#eventStore = eventStore\n  }\n  load(courseId) {\n    const streamName = `course-${courseId}`\n    const eventsForThisCourse = this.#eventStore.readStream(streamName)\n    return CourseAggregate.reconstitute(eventsForThisCourse)\n  }\n  save(course) {\n    const streamName = `course-${course.id}`\n    // fails if there are new events in the stream\n    // with a position &gt; course.version\n    this.#eventStore.appendToStream(\n      streamName,\n      course.pullRecordedEvents(),\n      {\n        streamState: course.version\n      }\n    )\n  }\n}\n</code></pre> <p></p> <p>It can be used with an <code>InMemoryEventStore.js</code></p> <pre><code>// create and save a new instance:\nconst repository = new CourseRepository(eventStore)\nconst course = CourseAggregate.create('c1', 'Course 01', 10)\nrepository.save(course)\n\n// update an existing instance:\nconst course2 = repository.load('c1')\ncourse2.changeCapacity(15)\nrepository.save(course2)\n\nconsole.log(\n  eventStore.readStream('course-c1')\n  .map(e =&gt; e.type)\n) // [\"CourseDefined\",\"CourseCapacityChanged\"]\n</code></pre> <p></p>"},{"location":"examples/event-sourced-aggregate/#dcb-approach","title":"DCB approach","text":"<p>With DCB we can reuse the <code>CourseAggregate</code> from above and only need to adjust the repository implementation:</p> DcbCourseRepository.js<pre><code>class DcbCourseRepository {\n  #eventStore\n  constructor(eventStore) {\n    this.#eventStore = eventStore\n  }\n  load(courseId) {\n    const tags = [`course:${courseId}`]\n    const query = createQuery([{ tags }])\n    const eventsForThisCourse = this.#eventStore.read(query)\n    return CourseAggregate.reconstitute(eventsForThisCourse)\n  }\n  save(course) {\n    const tags = [`course:${course.id}`]\n    const query = createQuery([{ tags }])\n    const eventsWithTags = course\n      .pullRecordedEvents()\n      .map((event) =&gt; ({ ...event, tags }))\n    this.#eventStore.append(eventsWithTags, {\n      failIfEventsMatch: query,\n      after: course.version,\n    })\n  }\n}\n</code></pre> <p></p> <p>It can be used with an <code>InMemoryDcbEventStore.js</code></p> <pre><code>// create and save a new instance:\nconst dcbEventStore = new InMemoryDcbEventStore()\nconst repository = new DcbCourseRepository(dcbEventStore)\nconst course = CourseAggregate.create(\"c1\", \"Course 01\", 10)\nrepository.save(course)\n\n// update an existing instance:\nconst course2 = repository.load(\"c1\")\ncourse2.changeCapacity(15)\nrepository.save(course2)\n\nconsole.log(\n  dcbEventStore.read(createQuery([{ tags: [\"course:c1\"] }])).first()\n) // {type: 'CourseDefined', data: { courseId: 'c1', title: 'Course 01', capacity: 10 }, tags: [ 'course:c1' ], position: 1}\n</code></pre> <p></p>"},{"location":"examples/event-sourced-aggregate/#conclusion","title":"Conclusion","text":"<p>This example demonstrates how the Aggregate pattern can be used with DCB</p>"},{"location":"examples/invoice-number/","title":"Invoice number","text":"<p>Creating a monotonic sequence without gaps is another common requirement DCB can help with</p>"},{"location":"examples/invoice-number/#challenge","title":"Challenge","text":"<p>Create invoices with unique numbers that form an unbroken sequence</p>"},{"location":"examples/invoice-number/#traditional-approaches","title":"Traditional approaches","text":"<p>As this challenge is similar to the Unique username example, the traditional approaches are the same.</p>"},{"location":"examples/invoice-number/#dcb-approach","title":"DCB approach","text":"<p>This requirement could be solved with an in-memory Projection that calculates the <code>nextInvoiceNumber</code>:</p> JavaScriptTypeScriptGWT (WIP) Info <p>This example uses composed projections to build Decision Models (explore library source code )</p> <p><pre><code>// event type definitions:\n\nfunction InvoiceCreated({ invoiceNumber, invoiceData }) {\n  return {\n    type: \"InvoiceCreated\",\n    data: { invoiceNumber, invoiceData },\n    tags: [`invoice:${invoiceNumber}`],\n  }\n}\n\n// projections for decision models:\n\nfunction NextInvoiceNumberProjection(value) {\n  return createProjection({\n    initialState: 1,\n    handlers: {\n      InvoiceCreated: (state, event) =&gt; event.data.invoiceNumber + 1,\n    },\n  })\n}\n\n// command handlers:\n\nclass Api {\n  eventStore\n  constructor(eventStore) {\n    this.eventStore = eventStore\n  }\n\n  createInvoice(command) {\n    const { state, appendCondition } = buildDecisionModel(this.eventStore, {\n      nextInvoiceNumber: NextInvoiceNumberProjection(),\n    })\n    this.eventStore.append(\n      InvoiceCreated({\n        invoiceNumber: state.nextInvoiceNumber,\n        invoiceData: command.invoiceData,\n      }),\n      appendCondition\n    )\n  }\n}\n\n// test cases:\n\nconst eventStore = new InMemoryDcbEventStore()\nconst api = new Api(eventStore)\nrunTests(api, eventStore, [\n  {\n    description: \"Create first invoice\",\n    when: {\n      command: {\n        type: \"createInvoice\",\n        data: {\"invoiceData\":{\"foo\":\"bar\"}},\n      }\n    },\n    then: {\n      expectedEvent: InvoiceCreated({\"invoiceNumber\":1,\"invoiceData\":{\"foo\":\"bar\"}}),\n    }\n  }, \n  {\n    description: \"Create second invoice\",\n    given: {\n      events: [\n        InvoiceCreated({\"invoiceNumber\":1,\"invoiceData\":{\"foo\":\"bar\"}}),\n      ],\n    },\n    when: {\n      command: {\n        type: \"createInvoice\",\n        data: {\"invoiceData\":{\"bar\":\"baz\"}},\n      }\n    },\n    then: {\n      expectedEvent: InvoiceCreated({\"invoiceNumber\":2,\"invoiceData\":{\"bar\":\"baz\"}}),\n    }\n  }, \n])\n</code></pre> </p> Info <p>This example uses composed projections to build Decision Models (explore library source code )</p> <pre><code>// event type definitions:\n\nfunction InvoiceCreated({\n  invoiceNumber,\n  invoiceData,\n} : {\n  invoiceNumber: number,\n  invoiceData: {  },\n}) {\n  return {\n    type: \"InvoiceCreated\" as const,\n    data: { invoiceNumber, invoiceData },\n    tags: [`invoice:${invoiceNumber}`],\n  }\n}\n\ntype EventTypes = ReturnType&lt;typeof InvoiceCreated&gt;\n\n// projections for decision models:\n\nfunction NextInvoiceNumberProjection() {\n  return createProjection&lt;EventTypes, number&gt;({\n    initialState: 1,\n    handlers: {\n      InvoiceCreated: (state, event) =&gt; event.data.invoiceNumber + 1,\n    },\n  })\n}\n\n// command handlers:\n\nclass Api {\n  constructor(private eventStore: EventStore) {}\n\n  createInvoice(command: { invoiceData: {  } }) {\n    const { state, appendCondition } = buildDecisionModel(this.eventStore, {\n      nextInvoiceNumber: NextInvoiceNumberProjection(),\n    })\n    this.eventStore.append(\n      InvoiceCreated({\n        invoiceNumber: state.nextInvoiceNumber,\n        invoiceData: command.invoiceData,\n      }),\n      appendCondition\n    )\n  }\n}\n</code></pre> Experimental: 3rd party library <p>These Given/When/Then scenarios are visualized using an unofficial, work-in-progress, library</p> <p></p>"},{"location":"examples/invoice-number/#better-performance","title":"Better performance","text":"<p>With this approach, every past <code>InvoiceCreated</code> event must be loaded just to determine the next invoice number. And although this may not introduce significant performance concerns with hundreds or even thousands of invoices \u2014 depending on how fast the underlying Event Store is \u2014 it remains a suboptimal and inefficient design choice.</p>"},{"location":"examples/invoice-number/#snapshots","title":"Snapshots","text":"<p>One workaround would be to use a Snapshot to reduce the number of Events to load but this increases complexity and adds new infrastructure requirements. </p>"},{"location":"examples/invoice-number/#only-load-a-single-event","title":"Only load a single Event","text":"<p>Some DCB compliant Event Stores support returning only the last matching Event for a given <code>QueryItem</code>, such that the projection could be rewritten like this:</p> <pre><code>function NextInvoiceNumberProjection(value) {\n  return createProjection({\n    initialState: 1,\n    handlers: {\n      InvoiceCreated: (state, event) =&gt; event.data.invoiceNumber + 1,\n    },\n    onlyLastEvent: true,\n  })\n}\n</code></pre> <p>Alternatively, for this specific scenario, the last <code>InvoiceCreated</code> Event can be loaded \"manually\":</p> <pre><code>// event type definitions:\n\nfunction InvoiceCreated({ invoiceNumber, invoiceData }) {\n  return {\n    type: \"InvoiceCreated\",\n    data: { invoiceNumber, invoiceData },\n    tags: [`invoice:${invoiceNumber}`],\n  }\n}\n\n// projections for decision models:\n\nfunction NextInvoiceNumberProjection(value) {\n  return createProjection({\n    initialState: 1,\n    handlers: {\n      InvoiceCreated: (state, event) =&gt; event.data.invoiceNumber + 1,\n    },\n  })\n}\n\n// command handlers:\n\nclass Api {\n  eventStore\n  constructor(eventStore) {\n    this.eventStore = eventStore\n  }\n\n  createInvoice(command) {\n    const projection = NextInvoiceNumberProjection()\n    const lastInvoiceCreatedEvent = this.eventStore\n      .read(projection.query, {\n        backwards: true,\n        limit: 1,\n      })\n      .first()\n\n    const nextInvoiceNumber = lastInvoiceCreatedEvent\n      ? projection.apply(\n          projection.initialState,\n          lastInvoiceCreatedEvent\n        )\n      : projection.initialState\n\n    const appendCondition = {\n      failIfEventsMatch: projection.query,\n      after: lastInvoiceCreatedEvent?.position,\n    }\n\n    this.eventStore.append(\n      new InvoiceCreated({\n        invoiceNumber: nextInvoiceNumber,\n        invoiceData: command.invoiceData,\n      }),\n      appendCondition\n    )\n  }\n}\n\nconst eventStore = new InMemoryDcbEventStore()\nconst api = new Api(eventStore)\napi.createInvoice({invoiceData: {foo: \"bar\"}})\nconsole.log(eventStore.read(queryAll()).first())\n</code></pre> <p></p>"},{"location":"examples/invoice-number/#conclusion","title":"Conclusion","text":"<p>This example demonstrates how a DCB compliant Event Store can simplify the creation of monotonic sequences</p>"},{"location":"examples/opt-in-token/","title":"Opt-In Token","text":"<p>This example demonstrates how DCB can be leveraged to replace a Read Model when implementing a Double opt-in</p>"},{"location":"examples/opt-in-token/#challenge","title":"Challenge","text":"<p>A Double opt-in process that requires users to confirm their email address before an account is created</p>"},{"location":"examples/opt-in-token/#traditional-approaches","title":"Traditional approaches","text":"<ul> <li> <p>Stateless: Store required data and expiration timestamp in an encrypted/signed token</p> <p> This works, but it can lead to very long tokens</p> </li> <li> <p>Persisted token: The server generates and stores a unique token, tied to the specified email address. When the email address is confirmed, the token is verified and invalidated (e.g., deleted).</p> <p> This method allows the tokens to be short but adds infrastructure overhead and complexity, and may result in stale or unused tokens accumulating over time</p> </li> </ul>"},{"location":"examples/opt-in-token/#dcb-approach","title":"DCB approach","text":"<p>With DCB, a short token (i.e. OTP) can be generated on the server and stored with the data of the initial Event (<code>SignUpInitiated</code>).</p> <p>With that, a dedicated Decision Model can be created that verifies the token. The token is invalidated as soon as the sign up was finalized (<code>SignUpConfirmed</code> Event)</p>"},{"location":"examples/opt-in-token/#feature-1-simple-one-time-password-otp","title":"Feature 1: Simple One-Time Password (OTP)","text":"JavaScriptTypeScriptGWT (WIP) Info <p>This example uses composed projections to build Decision Models (explore library source code )</p> <p><pre><code>// event type definitions:\n\nfunction SignUpInitiated({ emailAddress, otp, name }) {\n  return {\n    type: \"SignUpInitiated\",\n    data: { emailAddress, otp, name },\n    tags: [`email:${emailAddress}`, `otp:${otp}`],\n  }\n}\n\nfunction SignUpConfirmed({ emailAddress, otp, name }) {\n  return {\n    type: \"SignUpConfirmed\",\n    data: { emailAddress, otp, name },\n    tags: [`email:${emailAddress}`, `otp:${otp}`],\n  }\n}\n\n// projections for decision models:\n\nfunction PendingSignUpProjection(emailAddress, otp) {\n  return createProjection({\n    initialState: null,\n    handlers: {\n      SignUpInitiated: (state, event) =&gt; ({data: event.data, otpUsed: false}),\n      SignUpConfirmed: (state, event) =&gt; ({...state, otpUsed: true}),\n    },\n    tagFilter: [`email:${emailAddress}`, `otp:${otp}`],\n  })\n}\n\n// command handlers:\n\nclass Api {\n  eventStore\n  constructor(eventStore) {\n    this.eventStore = eventStore\n  }\n\n  confirmSignUp(command) {\n    const { state, appendCondition } = buildDecisionModel(this.eventStore, {\n      pendingSignUp: PendingSignUpProjection(command.emailAddress, command.otp),\n    })\n    if (!state.pendingSignUp) {\n      throw new Error(\"No pending sign-up for this OTP / email address\")\n    }\n    if (state.pendingSignUp.otpUsed) {\n      throw new Error(\"OTP was already used\")\n    }\n    this.eventStore.append(\n      SignUpConfirmed({\n        emailAddress: command.emailAddress,\n        otp: command.otp,\n        name: state.pendingSignUp.data.name,\n      }),\n      appendCondition\n    )\n  }\n}\n\n// test cases:\n\nconst eventStore = new InMemoryDcbEventStore()\nconst api = new Api(eventStore)\nrunTests(api, eventStore, [\n  {\n    description: \"Confirm SignUp for non-existing OTP\",\n    when: {\n      command: {\n        type: \"confirmSignUp\",\n        data: {\"emailAddress\":\"john.doe@example.com\",\"otp\":\"000000\"},\n      }\n    },\n    then: {\n      expectedError: \"No pending sign-up for this OTP \\/ email address\",\n    }\n  }, \n  {\n    description: \"Confirm SignUp for OTP assigned to different email address\",\n    given: {\n      events: [\n        SignUpInitiated({\"emailAddress\":\"john.doe@example.com\",\"otp\":\"111111\",\"name\":\"John Doe\"}),\n      ],\n    },\n    when: {\n      command: {\n        type: \"confirmSignUp\",\n        data: {\"emailAddress\":\"jane.doe@example.com\",\"otp\":\"111111\"},\n      }\n    },\n    then: {\n      expectedError: \"No pending sign-up for this OTP \\/ email address\",\n    }\n  }, \n  {\n    description: \"Confirm SignUp for already used OTP\",\n    given: {\n      events: [\n        SignUpInitiated({\"emailAddress\":\"john.doe@example.com\",\"otp\":\"222222\",\"name\":\"John Doe\"}),\n        SignUpConfirmed({\"emailAddress\":\"john.doe@example.com\",\"otp\":\"222222\",\"name\":\"John Doe\"}),\n      ],\n    },\n    when: {\n      command: {\n        type: \"confirmSignUp\",\n        data: {\"emailAddress\":\"john.doe@example.com\",\"otp\":\"222222\"},\n      }\n    },\n    then: {\n      expectedError: \"OTP was already used\",\n    }\n  }, \n  {\n    description: \"Confirm SignUp for valid OTP\",\n    given: {\n      events: [\n        SignUpInitiated({\"emailAddress\":\"john.doe@example.com\",\"otp\":\"444444\",\"name\":\"John Doe\"}),\n      ],\n    },\n    when: {\n      command: {\n        type: \"confirmSignUp\",\n        data: {\"emailAddress\":\"john.doe@example.com\",\"otp\":\"444444\"},\n      }\n    },\n    then: {\n      expectedEvent: SignUpConfirmed({\"emailAddress\":\"john.doe@example.com\",\"otp\":\"444444\",\"name\":\"John Doe\"}),\n    }\n  }, \n])\n</code></pre> </p> Info <p>This example uses composed projections to build Decision Models (explore library source code )</p> <pre><code>// event type definitions:\n\nfunction SignUpInitiated({\n  emailAddress,\n  otp,\n  name,\n} : {\n  emailAddress: string,\n  otp: string,\n  name: string,\n}) {\n  return {\n    type: \"SignUpInitiated\" as const,\n    data: { emailAddress, otp, name },\n    tags: [`email:${emailAddress}`, `otp:${otp}`],\n  }\n}\n\nfunction SignUpConfirmed({\n  emailAddress,\n  otp,\n  name,\n} : {\n  emailAddress: string,\n  otp: string,\n  name: string,\n}) {\n  return {\n    type: \"SignUpConfirmed\" as const,\n    data: { emailAddress, otp, name },\n    tags: [`email:${emailAddress}`, `otp:${otp}`],\n  }\n}\n\ntype EventTypes = ReturnType&lt;\n  | typeof SignUpInitiated,\n  | typeof SignUpConfirmed,\n&gt;\n\n// projections for decision models:\n\nfunction PendingSignUpProjection(emailAddress: string, otp: string) {\n  return createProjection&lt;EventTypes, { data: { name: string }; otpUsed: boolean }&gt;({\n    initialState: null,\n    handlers: {\n      SignUpInitiated: (state, event) =&gt; ({data: event.data, otpUsed: false}),\n      SignUpConfirmed: (state, event) =&gt; ({...state, otpUsed: true}),\n    },\n    tagFilter: [`email:${emailAddress}`, `otp:${otp}`],\n  })\n}\n\n// command handlers:\n\nclass Api {\n  constructor(private eventStore: EventStore) {}\n\n  confirmSignUp(command: { emailAddress: string; otp: string }) {\n    const { state, appendCondition } = buildDecisionModel(this.eventStore, {\n      pendingSignUp: PendingSignUpProjection(command.emailAddress, command.otp),\n    })\n    if (!state.pendingSignUp) {\n      throw new Error(\"No pending sign-up for this OTP / email address\")\n    }\n    if (state.pendingSignUp.otpUsed) {\n      throw new Error(\"OTP was already used\")\n    }\n    this.eventStore.append(\n      SignUpConfirmed({\n        emailAddress: command.emailAddress,\n        otp: command.otp,\n        name: state.pendingSignUp.data.name,\n      }),\n      appendCondition\n    )\n  }\n}\n</code></pre> Experimental: 3rd party library <p>These Given/When/Then scenarios are visualized using an unofficial, work-in-progress, library</p> <p></p>"},{"location":"examples/opt-in-token/#feature-2-expiring-otp","title":"Feature 2: Expiring OTP","text":"<p>A requirement might be to expire tokens after a given time (for example: 60 minutes). The example can be easily adjusted to implement that feature:</p> <p>Note</p> <p>The <code>minutesAgo</code> property of the Event metadata is a simplification. Typically, a timestamp representing the Event's recording time is stored within the Event's payload or metadata. This timestamp can be compared to the current date to determine the Event's age in the decision model.</p> JavaScriptTypeScriptGWT (WIP) Info <p>This example uses composed projections to build Decision Models (explore library source code )</p> <p><pre><code>// event type definitions:\n\nfunction SignUpInitiated({ emailAddress, otp, name }) {\n  return {\n    type: \"SignUpInitiated\",\n    data: { emailAddress, otp, name },\n    tags: [`email:${emailAddress}`, `otp:${otp}`],\n  }\n}\n\nfunction SignUpConfirmed({ emailAddress, otp, name }) {\n  return {\n    type: \"SignUpConfirmed\",\n    data: { emailAddress, otp, name },\n    tags: [`email:${emailAddress}`, `otp:${otp}`],\n  }\n}\n\n// projections for decision models:\n\nfunction PendingSignUpProjection(emailAddress, otp) {\n  return createProjection({\n    initialState: null,\n    handlers: {\n      SignUpInitiated: (state, event) =&gt; ({data: event.data, otpUsed: false, otpExpired: event.metadata?.minutesAgo &gt; 60}),\n      SignUpConfirmed: (state, event) =&gt; ({...state, otpUsed: true}),\n    },\n    tagFilter: [`email:${emailAddress}`, `otp:${otp}`],\n  })\n}\n\n// command handlers:\n\nclass Api {\n  eventStore\n  constructor(eventStore) {\n    this.eventStore = eventStore\n  }\n\n  confirmSignUp(command) {\n    const { state, appendCondition } = buildDecisionModel(this.eventStore, {\n      pendingSignUp: PendingSignUpProjection(command.emailAddress, command.otp),\n    })\n    if (!state.pendingSignUp) {\n      throw new Error(\"No pending sign-up for this OTP / email address\")\n    }\n    if (state.pendingSignUp.otpUsed) {\n      throw new Error(\"OTP was already used\")\n    }\n    if (state.pendingSignUp.otpExpired) {\n      throw new Error(\"OTP expired\")\n    }\n    this.eventStore.append(\n      SignUpConfirmed({\n        emailAddress: command.emailAddress,\n        otp: command.otp,\n        name: state.pendingSignUp.data.name,\n      }),\n      appendCondition\n    )\n  }\n}\n\n// test cases:\n\nconst eventStore = new InMemoryDcbEventStore()\nconst api = new Api(eventStore)\nrunTests(api, eventStore, [\n  {\n    description: \"Confirm SignUp for non-existing OTP\",\n    when: {\n      command: {\n        type: \"confirmSignUp\",\n        data: {\"emailAddress\":\"john.doe@example.com\",\"otp\":\"000000\"},\n      }\n    },\n    then: {\n      expectedError: \"No pending sign-up for this OTP \\/ email address\",\n    }\n  }, \n  {\n    description: \"Confirm SignUp for OTP assigned to different email address\",\n    given: {\n      events: [\n        SignUpInitiated({\"emailAddress\":\"john.doe@example.com\",\"otp\":\"111111\",\"name\":\"John Doe\"}),\n      ],\n    },\n    when: {\n      command: {\n        type: \"confirmSignUp\",\n        data: {\"emailAddress\":\"jane.doe@example.com\",\"otp\":\"111111\"},\n      }\n    },\n    then: {\n      expectedError: \"No pending sign-up for this OTP \\/ email address\",\n    }\n  }, \n  {\n    description: \"Confirm SignUp for already used OTP\",\n    given: {\n      events: [\n        SignUpInitiated({\"emailAddress\":\"john.doe@example.com\",\"otp\":\"222222\",\"name\":\"John Doe\"}),\n        SignUpConfirmed({\"emailAddress\":\"john.doe@example.com\",\"otp\":\"222222\",\"name\":\"John Doe\"}),\n      ],\n    },\n    when: {\n      command: {\n        type: \"confirmSignUp\",\n        data: {\"emailAddress\":\"john.doe@example.com\",\"otp\":\"222222\"},\n      }\n    },\n    then: {\n      expectedError: \"OTP was already used\",\n    }\n  }, \n  {\n    description: \"Confirm SignUp for valid OTP\",\n    given: {\n      events: [\n        SignUpInitiated({\"emailAddress\":\"john.doe@example.com\",\"otp\":\"444444\",\"name\":\"John Doe\"}),\n      ],\n    },\n    when: {\n      command: {\n        type: \"confirmSignUp\",\n        data: {\"emailAddress\":\"john.doe@example.com\",\"otp\":\"444444\"},\n      }\n    },\n    then: {\n      expectedEvent: SignUpConfirmed({\"emailAddress\":\"john.doe@example.com\",\"otp\":\"444444\",\"name\":\"John Doe\"}),\n    }\n  }, \n  {\n    description: \"Confirm SignUp for expired OTP\",\n    given: {\n      events: [\n        addEventMetadata(SignUpInitiated({\"emailAddress\":\"john.doe@example.com\",\"otp\":\"333333\",\"name\":\"John Doe\"}), {\"minutesAgo\":\"61\"}),\n      ],\n    },\n    when: {\n      command: {\n        type: \"confirmSignUp\",\n        data: {\"emailAddress\":\"john.doe@example.com\",\"otp\":\"000000\"},\n      }\n    },\n    then: {\n      expectedError: \"No pending sign-up for this OTP \\/ email address\",\n    }\n  }, \n])\n</code></pre> </p> Info <p>This example uses composed projections to build Decision Models (explore library source code )</p> <pre><code>// event type definitions:\n\nfunction SignUpInitiated({\n  emailAddress,\n  otp,\n  name,\n} : {\n  emailAddress: string,\n  otp: string,\n  name: string,\n}) {\n  return {\n    type: \"SignUpInitiated\" as const,\n    data: { emailAddress, otp, name },\n    tags: [`email:${emailAddress}`, `otp:${otp}`],\n  }\n}\n\nfunction SignUpConfirmed({\n  emailAddress,\n  otp,\n  name,\n} : {\n  emailAddress: string,\n  otp: string,\n  name: string,\n}) {\n  return {\n    type: \"SignUpConfirmed\" as const,\n    data: { emailAddress, otp, name },\n    tags: [`email:${emailAddress}`, `otp:${otp}`],\n  }\n}\n\ntype EventTypes = ReturnType&lt;\n  | typeof SignUpInitiated,\n  | typeof SignUpConfirmed,\n&gt;\n\n// projections for decision models:\n\nfunction PendingSignUpProjection(emailAddress: string, otp: string) {\n  return createProjection&lt;EventTypes, { data: { name: string }; otpUsed: boolean; otpExpired: boolean }&gt;({\n    initialState: null,\n    handlers: {\n      SignUpInitiated: (state, event) =&gt; ({data: event.data, otpUsed: false, otpExpired: event.metadata?.minutesAgo &gt; 60}),\n      SignUpConfirmed: (state, event) =&gt; ({...state, otpUsed: true}),\n    },\n    tagFilter: [`email:${emailAddress}`, `otp:${otp}`],\n  })\n}\n\n// command handlers:\n\nclass Api {\n  constructor(private eventStore: EventStore) {}\n\n  confirmSignUp(command: { emailAddress: string; otp: string }) {\n    const { state, appendCondition } = buildDecisionModel(this.eventStore, {\n      pendingSignUp: PendingSignUpProjection(command.emailAddress, command.otp),\n    })\n    if (!state.pendingSignUp) {\n      throw new Error(\"No pending sign-up for this OTP / email address\")\n    }\n    if (state.pendingSignUp.otpUsed) {\n      throw new Error(\"OTP was already used\")\n    }\n    if (state.pendingSignUp.otpExpired) {\n      throw new Error(\"OTP expired\")\n    }\n    this.eventStore.append(\n      SignUpConfirmed({\n        emailAddress: command.emailAddress,\n        otp: command.otp,\n        name: state.pendingSignUp.data.name,\n      }),\n      appendCondition\n    )\n  }\n}\n</code></pre> Experimental: 3rd party library <p>These Given/When/Then scenarios are visualized using an unofficial, work-in-progress, library</p> <p></p>"},{"location":"examples/opt-in-token/#conclusion","title":"Conclusion","text":"<p>This example demonstrates, how DCB can be used to implement a simple double opt-in functionality without the need for additional Read Models or Cryptography</p>"},{"location":"examples/prevent-record-duplication/","title":"Prevent record duplication","text":"<p>In distributed systems, especially in web APIs handling financial or state-changing operations, ensuring idempotency is essential. Clients may retry requests due to network issues or timeouts, and without proper safeguards, this can result in duplicate processing.</p>"},{"location":"examples/prevent-record-duplication/#challenge","title":"Challenge","text":"<p>We want to guarantee that a particular operation (e.g., a payment request or form submission) is only processed once, even if the request is repeated. This requires that the backend detects duplicates and ignores repeated executions.</p> <p>Key difficulties include:</p> <ul> <li>Generating a unique key reliably on the frontend</li> <li>Storing and enforcing uniqueness constraints server-side</li> <li>Ensuring statelessness in APIs while maintaining safety</li> </ul>"},{"location":"examples/prevent-record-duplication/#traditional-approaches","title":"Traditional approaches","text":"<p>Traditionally, the frontend prevents accidental re-submissions, e.g. by disabling a form upon submit. This makes a lot of sense of course. But it is not waterproof and sometimes not an option (for HTTP APIs for example).</p> <p>To prevent double submissions on the server-side, several strategies can be used:</p> <ul> <li> <p>Client-generated identifier: The frontend generates some UUID (or another unique key) to serve as the identifier for the entity being created. The backend then rejects the request if the corresponding Event stream already contains Events</p> <p> While effective, this approach gives the client control over domain entity identifiers, which can introduce potential security risks</p> </li> <li> <p>Pre-issued server token: The server generates and stores a unique token before the form is rendered. When the form is submitted, the token is verified and invalidated (e.g., deleted).</p> <p> This method is reliable but adds infrastructure overhead and complexity, and may result in stale or unused tokens accumulating over time</p> </li> </ul>"},{"location":"examples/prevent-record-duplication/#dcb-approach","title":"DCB approach","text":"<p>With DCB, a random <code>idempotency token</code> can be safely generated on the client side and included in the command. When the corresponding Event is persisted, the token is stored alongside the server-generated entity identifier.</p> <p>With that, a Decision Model can be created that is responsible for validating the uniqueness of the token within the context of that operation \u2014 ensuring that the same token cannot be used more than once. This allows the server to enforce idempotency without exposing domain identifiers to the client or requiring additional infrastructure for token tracking:</p> JavaScriptTypeScriptGWT (WIP) Info <p>This example uses composed projections to build Decision Models (explore library source code )</p> <p><pre><code>// event type definitions:\n\nfunction OrderPlaced({ orderId, idempotencyToken }) {\n  return {\n    type: \"OrderPlaced\",\n    data: { orderId, idempotencyToken },\n    tags: [`order:${orderId}`, `idempotency:${idempotencyToken}`],\n  }\n}\n\n// projections for decision models:\n\nfunction IdempotencyTokenWasUsedProjection(idempotencyToken) {\n  return createProjection({\n    initialState: false,\n    handlers: {\n      OrderPlaced: (state, event) =&gt; true,\n    },\n    tagFilter: [`idempotency:${idempotencyToken}`],\n  })\n}\n\n// command handlers:\n\nclass Api {\n  eventStore\n  constructor(eventStore) {\n    this.eventStore = eventStore\n  }\n\n  placeOrder(command) {\n    const { state, appendCondition } = buildDecisionModel(this.eventStore, {\n      idempotencyTokenWasUsed: IdempotencyTokenWasUsedProjection(command.idempotencyToken),\n    })\n    if (state.idempotencyTokenWasUsed) {\n      throw new Error(\"Re-submission\")\n    }\n    this.eventStore.append(\n      OrderPlaced({\n        orderId: command.orderId,\n        idempotencyToken: command.idempotencyToken,\n      }),\n      appendCondition\n    )\n  }\n}\n\n// test cases:\n\nconst eventStore = new InMemoryDcbEventStore()\nconst api = new Api(eventStore)\nrunTests(api, eventStore, [\n  {\n    description: \"Place order with previously used idempotency token\",\n    given: {\n      events: [\n        OrderPlaced({\"orderId\":\"o12345\",\"idempotencyToken\":\"11111\"}),\n      ],\n    },\n    when: {\n      command: {\n        type: \"placeOrder\",\n        data: {\"orderId\":\"o54321\",\"idempotencyToken\":\"11111\"},\n      }\n    },\n    then: {\n      expectedError: \"Re-submission\",\n    }\n  }, \n  {\n    description: \"Place order with new idempotency token\",\n    given: {\n      events: [\n        OrderPlaced({\"orderId\":\"o12345\",\"idempotencyToken\":\"11111\"}),\n      ],\n    },\n    when: {\n      command: {\n        type: \"placeOrder\",\n        data: {\"orderId\":\"o54321\",\"idempotencyToken\":\"22222\"},\n      }\n    },\n    then: {\n      expectedEvent: OrderPlaced({\"orderId\":\"o54321\",\"idempotencyToken\":\"22222\"}),\n    }\n  }, \n])\n</code></pre> </p> Info <p>This example uses composed projections to build Decision Models (explore library source code )</p> <pre><code>// event type definitions:\n\nfunction OrderPlaced({\n  orderId,\n  idempotencyToken,\n} : {\n  orderId: string,\n  idempotencyToken: string,\n}) {\n  return {\n    type: \"OrderPlaced\" as const,\n    data: { orderId, idempotencyToken },\n    tags: [`order:${orderId}`, `idempotency:${idempotencyToken}`],\n  }\n}\n\ntype EventTypes = ReturnType&lt;typeof OrderPlaced&gt;\n\n// projections for decision models:\n\nfunction IdempotencyTokenWasUsedProjection(idempotencyToken: string) {\n  return createProjection&lt;EventTypes, boolean&gt;({\n    initialState: false,\n    handlers: {\n      OrderPlaced: (state, event) =&gt; true,\n    },\n    tagFilter: [`idempotency:${idempotencyToken}`],\n  })\n}\n\n// command handlers:\n\nclass Api {\n  constructor(private eventStore: EventStore) {}\n\n  placeOrder(command: { orderId: string; idempotencyToken: string }) {\n    const { state, appendCondition } = buildDecisionModel(this.eventStore, {\n      idempotencyTokenWasUsed: IdempotencyTokenWasUsedProjection(command.idempotencyToken),\n    })\n    if (state.idempotencyTokenWasUsed) {\n      throw new Error(\"Re-submission\")\n    }\n    this.eventStore.append(\n      OrderPlaced({\n        orderId: command.orderId,\n        idempotencyToken: command.idempotencyToken,\n      }),\n      appendCondition\n    )\n  }\n}\n</code></pre> Experimental: 3rd party library <p>These Given/When/Then scenarios are visualized using an unofficial, work-in-progress, library</p> <p></p> <p>Of course, the example can be extended to also ensure uniqueness of the  <code>orderId</code> and/or to allow a token to be reused once the order was placed.</p>"},{"location":"examples/prevent-record-duplication/#conclusion","title":"Conclusion","text":"<p>This example demonstrates, how DCB allows to enforce constraints that are not directly related to the domain.</p> <p>Note: This example is about preventing accidental re-submissions. The Opt-In Token example demonstrates how to prevent fraudulent manipulation.</p>"},{"location":"examples/unique-username/","title":"Unique username example","text":"<p>Enforcing globally unique values is simple with strong consistency (thanks to tools like unique constraint indexes), but it becomes significantly more challenging with eventual consistency.</p>"},{"location":"examples/unique-username/#challenge","title":"Challenge","text":"<p>The goal is an application that allows users to subscribe with a username that uniquely identifies them.</p> <p>As a bonus, this example is extended by adding the following features:</p> <ul> <li>Allow usernames to be re-claimed when the account was closed (see disclaimer!)</li> <li>Allow users to change their username</li> <li>Only release unused usernames after a configurable delay</li> </ul>"},{"location":"examples/unique-username/#traditional-approaches","title":"Traditional approaches","text":"<p>There are a couple of common strategies to achieve global uniqueness in event-driven systems:</p> <ul> <li> <p>Eventual consistency: Use a Read Model to check for uniqueness and handle a duplication due to race conditions after the fact (e.g. by deactivating the account or changing the username)</p> <p> This is of course a potential solution, with or without DCB, but it falls outside the scope of these examples</p> </li> <li> <p>Dedicated storage: Create a dedicated storage for allocated usernames and make the write side insert a record when the corresponding Event is recorded</p> <p> This adds a source of error and potentially locked usernames unless Event and storage update can be done in a single transaction</p> </li> <li> <p>Reservation Pattern: Use the Reservation Pattern to lock a username and only continue if the locking succeeded</p> <p> This works but adds quite a lot of complexity and additional Events and the need for Sagas or multiple writes in a single request</p> </li> </ul>"},{"location":"examples/unique-username/#dcb-approach","title":"DCB approach","text":"<p>With DCB all Events that affect the unique constraint (the username in this example) can be tagged with the corresponding value (or a hash of it):</p> <p></p>"},{"location":"examples/unique-username/#feature-1-globally-unique-username","title":"Feature 1: Globally unique username","text":"<p>This example is the most simple one just checking whether a given username is claimed</p> JavaScriptTypeScriptGWT (WIP) Info <p>This example uses composed projections to build Decision Models (explore library source code )</p> <p><pre><code>// event type definitions:\n\nfunction AccountRegistered({ username }) {\n  return {\n    type: \"AccountRegistered\",\n    data: { username },\n    tags: [`username:${username}`],\n  }\n}\n\n// projections for decision models:\n\nfunction IsUsernameClaimedProjection(username) {\n  return createProjection({\n    initialState: false,\n    handlers: {\n      AccountRegistered: (state, event) =&gt; true,\n    },\n    tagFilter: [`username:${username}`],\n  })\n}\n\n// command handlers:\n\nclass Api {\n  eventStore\n  constructor(eventStore) {\n    this.eventStore = eventStore\n  }\n\n  registerAccount(command) {\n    const { state, appendCondition } = buildDecisionModel(this.eventStore, {\n      isUsernameClaimed: IsUsernameClaimedProjection(command.username),\n    })\n    if (state.isUsernameClaimed) {\n      throw new Error(`Username \"${command.username}\" is claimed`)\n    }\n    this.eventStore.append(\n      AccountRegistered({\n        username: command.username,\n      }),\n      appendCondition\n    )\n  }\n}\n\n// test cases:\n\nconst eventStore = new InMemoryDcbEventStore()\nconst api = new Api(eventStore)\nrunTests(api, eventStore, [\n  {\n    description: \"Register account with claimed username\",\n    given: {\n      events: [\n        AccountRegistered({\"username\":\"u1\"}),\n      ],\n    },\n    when: {\n      command: {\n        type: \"registerAccount\",\n        data: {\"username\":\"u1\"},\n      }\n    },\n    then: {\n      expectedError: \"Username \\\"u1\\\" is claimed\",\n    }\n  }, \n  {\n    description: \"Register account with unused username\",\n    when: {\n      command: {\n        type: \"registerAccount\",\n        data: {\"username\":\"u1\"},\n      }\n    },\n    then: {\n      expectedEvent: AccountRegistered({\"username\":\"u1\"}),\n    }\n  }, \n])\n</code></pre> </p> Info <p>This example uses composed projections to build Decision Models (explore library source code )</p> <pre><code>// event type definitions:\n\nfunction AccountRegistered({\n  username,\n} : {\n  username: string,\n}) {\n  return {\n    type: \"AccountRegistered\" as const,\n    data: { username },\n    tags: [`username:${username}`],\n  }\n}\n\ntype EventTypes = ReturnType&lt;typeof AccountRegistered&gt;\n\n// projections for decision models:\n\nfunction IsUsernameClaimedProjection(username: string) {\n  return createProjection&lt;EventTypes, boolean&gt;({\n    initialState: false,\n    handlers: {\n      AccountRegistered: (state, event) =&gt; true,\n    },\n    tagFilter: [`username:${username}`],\n  })\n}\n\n// command handlers:\n\nclass Api {\n  constructor(private eventStore: EventStore) {}\n\n  registerAccount(command: { username: string }) {\n    const { state, appendCondition } = buildDecisionModel(this.eventStore, {\n      isUsernameClaimed: IsUsernameClaimedProjection(command.username),\n    })\n    if (state.isUsernameClaimed) {\n      throw new Error(`Username \"${command.username}\" is claimed`)\n    }\n    this.eventStore.append(\n      AccountRegistered({\n        username: command.username,\n      }),\n      appendCondition\n    )\n  }\n}\n</code></pre> Experimental: 3rd party library <p>These Given/When/Then scenarios are visualized using an unofficial, work-in-progress, library</p> <p></p>"},{"location":"examples/unique-username/#feature-2-release-usernames","title":"Feature 2: Release usernames","text":"<p>This example extends the previous one to show how a previously claimed username could be released when the corresponding account is closed</p> <p>Disclaimer</p> <p>It's most probably not a good idea to allow new users to take over the username of a closed account! Part 4 introduces a potential remedy, on its own this is merely an oversimplified example.</p> JavaScriptTypeScriptGWT (WIP) Info <p>This example uses composed projections to build Decision Models (explore library source code )</p> <p><pre><code>// event type definitions:\n\nfunction AccountRegistered({ username }) {\n  return {\n    type: \"AccountRegistered\",\n    data: { username },\n    tags: [`username:${username}`],\n  }\n}\n\nfunction AccountClosed({ username }) {\n  return {\n    type: \"AccountClosed\",\n    data: { username },\n    tags: [`username:${username}`],\n  }\n}\n\n// projections for decision models:\n\nfunction IsUsernameClaimedProjection(username) {\n  return createProjection({\n    initialState: false,\n    handlers: {\n      AccountRegistered: (state, event) =&gt; true,\n      AccountClosed: (state, event) =&gt; false,\n    },\n    tagFilter: [`username:${username}`],\n  })\n}\n\n// command handlers:\n\nclass Api {\n  eventStore\n  constructor(eventStore) {\n    this.eventStore = eventStore\n  }\n\n  registerAccount(command) {\n    const { state, appendCondition } = buildDecisionModel(this.eventStore, {\n      isUsernameClaimed: IsUsernameClaimedProjection(command.username),\n    })\n    if (state.isUsernameClaimed) {\n      throw new Error(`Username \"${command.username}\" is claimed`)\n    }\n    this.eventStore.append(\n      AccountRegistered({\n        username: command.username,\n      }),\n      appendCondition\n    )\n  }\n}\n\n// test cases:\n\nconst eventStore = new InMemoryDcbEventStore()\nconst api = new Api(eventStore)\nrunTests(api, eventStore, [\n  {\n    description: \"Register account with claimed username\",\n    given: {\n      events: [\n        AccountRegistered({\"username\":\"u1\"}),\n      ],\n    },\n    when: {\n      command: {\n        type: \"registerAccount\",\n        data: {\"username\":\"u1\"},\n      }\n    },\n    then: {\n      expectedError: \"Username \\\"u1\\\" is claimed\",\n    }\n  }, \n  {\n    description: \"Register account with unused username\",\n    when: {\n      command: {\n        type: \"registerAccount\",\n        data: {\"username\":\"u1\"},\n      }\n    },\n    then: {\n      expectedEvent: AccountRegistered({\"username\":\"u1\"}),\n    }\n  }, \n  {\n    description: \"Register account with username of closed account\",\n    given: {\n      events: [\n        AccountRegistered({\"username\":\"u1\"}),\n        AccountClosed({\"username\":\"u1\"}),\n      ],\n    },\n    when: {\n      command: {\n        type: \"registerAccount\",\n        data: {\"username\":\"u1\"},\n      }\n    },\n    then: {\n      expectedEvent: AccountRegistered({\"username\":\"u1\"}),\n    }\n  }, \n])\n</code></pre> </p> Info <p>This example uses composed projections to build Decision Models (explore library source code )</p> <pre><code>// event type definitions:\n\nfunction AccountRegistered({\n  username,\n} : {\n  username: string,\n}) {\n  return {\n    type: \"AccountRegistered\" as const,\n    data: { username },\n    tags: [`username:${username}`],\n  }\n}\n\nfunction AccountClosed({\n  username,\n} : {\n  username: string,\n}) {\n  return {\n    type: \"AccountClosed\" as const,\n    data: { username },\n    tags: [`username:${username}`],\n  }\n}\n\ntype EventTypes = ReturnType&lt;\n  | typeof AccountRegistered,\n  | typeof AccountClosed,\n&gt;\n\n// projections for decision models:\n\nfunction IsUsernameClaimedProjection(username: string) {\n  return createProjection&lt;EventTypes, boolean&gt;({\n    initialState: false,\n    handlers: {\n      AccountRegistered: (state, event) =&gt; true,\n      AccountClosed: (state, event) =&gt; false,\n    },\n    tagFilter: [`username:${username}`],\n  })\n}\n\n// command handlers:\n\nclass Api {\n  constructor(private eventStore: EventStore) {}\n\n  registerAccount(command: { username: string }) {\n    const { state, appendCondition } = buildDecisionModel(this.eventStore, {\n      isUsernameClaimed: IsUsernameClaimedProjection(command.username),\n    })\n    if (state.isUsernameClaimed) {\n      throw new Error(`Username \"${command.username}\" is claimed`)\n    }\n    this.eventStore.append(\n      AccountRegistered({\n        username: command.username,\n      }),\n      appendCondition\n    )\n  }\n}\n</code></pre> Experimental: 3rd party library <p>These Given/When/Then scenarios are visualized using an unofficial, work-in-progress, library</p> <p></p>"},{"location":"examples/unique-username/#feature-3-allow-changing-of-usernames","title":"Feature 3: Allow changing of usernames","text":"<p>This example extends the previous one to show how the username of an active account could be changed</p> JavaScriptTypeScriptGWT (WIP) Info <p>This example uses composed projections to build Decision Models (explore library source code )</p> <p><pre><code>// event type definitions:\n\nfunction AccountRegistered({ username }) {\n  return {\n    type: \"AccountRegistered\",\n    data: { username },\n    tags: [`username:${username}`],\n  }\n}\n\nfunction AccountClosed({ username }) {\n  return {\n    type: \"AccountClosed\",\n    data: { username },\n    tags: [`username:${username}`],\n  }\n}\n\nfunction UsernameChanged({ oldUsername, newUsername }) {\n  return {\n    type: \"UsernameChanged\",\n    data: { oldUsername, newUsername },\n    tags: [`username:${oldUsername}`, `username:${newUsername}`],\n  }\n}\n\n// projections for decision models:\n\nfunction IsUsernameClaimedProjection(username) {\n  return createProjection({\n    initialState: false,\n    handlers: {\n      AccountRegistered: (state, event) =&gt; true,\n      AccountClosed: (state, event) =&gt; false,\n      UsernameChanged: (state, event) =&gt; event.data.newUsername === username,\n    },\n    tagFilter: [`username:${username}`],\n  })\n}\n\n// command handlers:\n\nclass Api {\n  eventStore\n  constructor(eventStore) {\n    this.eventStore = eventStore\n  }\n\n  registerAccount(command) {\n    const { state, appendCondition } = buildDecisionModel(this.eventStore, {\n      isUsernameClaimed: IsUsernameClaimedProjection(command.username),\n    })\n    if (state.isUsernameClaimed) {\n      throw new Error(`Username \"${command.username}\" is claimed`)\n    }\n    this.eventStore.append(\n      AccountRegistered({\n        username: command.username,\n      }),\n      appendCondition\n    )\n  }\n}\n\n// test cases:\n\nconst eventStore = new InMemoryDcbEventStore()\nconst api = new Api(eventStore)\nrunTests(api, eventStore, [\n  {\n    description: \"Register account with claimed username\",\n    given: {\n      events: [\n        AccountRegistered({\"username\":\"u1\"}),\n      ],\n    },\n    when: {\n      command: {\n        type: \"registerAccount\",\n        data: {\"username\":\"u1\"},\n      }\n    },\n    then: {\n      expectedError: \"Username \\\"u1\\\" is claimed\",\n    }\n  }, \n  {\n    description: \"Register account with unused username\",\n    when: {\n      command: {\n        type: \"registerAccount\",\n        data: {\"username\":\"u1\"},\n      }\n    },\n    then: {\n      expectedEvent: AccountRegistered({\"username\":\"u1\"}),\n    }\n  }, \n  {\n    description: \"Register account with username of closed account\",\n    given: {\n      events: [\n        AccountRegistered({\"username\":\"u1\"}),\n        AccountClosed({\"username\":\"u1\"}),\n      ],\n    },\n    when: {\n      command: {\n        type: \"registerAccount\",\n        data: {\"username\":\"u1\"},\n      }\n    },\n    then: {\n      expectedEvent: AccountRegistered({\"username\":\"u1\"}),\n    }\n  }, \n  {\n    description: \"Register account with a username that was previously used and then changed\",\n    given: {\n      events: [\n        AccountRegistered({\"username\":\"u1\"}),\n        UsernameChanged({\"oldUsername\":\"u1\",\"newUsername\":\"u1changed\"}),\n      ],\n    },\n    when: {\n      command: {\n        type: \"registerAccount\",\n        data: {\"username\":\"u1\"},\n      }\n    },\n    then: {\n      expectedEvent: AccountRegistered({\"username\":\"u1\"}),\n    }\n  }, \n  {\n    description: \"Register account with a username that another username was changed to\",\n    given: {\n      events: [\n        AccountRegistered({\"username\":\"u1\"}),\n        UsernameChanged({\"oldUsername\":\"u1\",\"newUsername\":\"u1changed\"}),\n      ],\n    },\n    when: {\n      command: {\n        type: \"registerAccount\",\n        data: {\"username\":\"u1changed\"},\n      }\n    },\n    then: {\n      expectedError: \"Username \\\"u1changed\\\" is claimed\",\n    }\n  }, \n])\n</code></pre> </p> Info <p>This example uses composed projections to build Decision Models (explore library source code )</p> <pre><code>// event type definitions:\n\nfunction AccountRegistered({\n  username,\n} : {\n  username: string,\n}) {\n  return {\n    type: \"AccountRegistered\" as const,\n    data: { username },\n    tags: [`username:${username}`],\n  }\n}\n\nfunction AccountClosed({\n  username,\n} : {\n  username: string,\n}) {\n  return {\n    type: \"AccountClosed\" as const,\n    data: { username },\n    tags: [`username:${username}`],\n  }\n}\n\nfunction UsernameChanged({\n  oldUsername,\n  newUsername,\n} : {\n  oldUsername: string,\n  newUsername: string,\n}) {\n  return {\n    type: \"UsernameChanged\" as const,\n    data: { oldUsername, newUsername },\n    tags: [`username:${oldUsername}`, `username:${newUsername}`],\n  }\n}\n\ntype EventTypes = ReturnType&lt;\n  | typeof AccountRegistered,\n  | typeof AccountClosed,\n  | typeof UsernameChanged,\n&gt;\n\n// projections for decision models:\n\nfunction IsUsernameClaimedProjection(username: string) {\n  return createProjection&lt;EventTypes, boolean&gt;({\n    initialState: false,\n    handlers: {\n      AccountRegistered: (state, event) =&gt; true,\n      AccountClosed: (state, event) =&gt; false,\n      UsernameChanged: (state, event) =&gt; event.data.newUsername === username,\n    },\n    tagFilter: [`username:${username}`],\n  })\n}\n\n// command handlers:\n\nclass Api {\n  constructor(private eventStore: EventStore) {}\n\n  registerAccount(command: { username: string }) {\n    const { state, appendCondition } = buildDecisionModel(this.eventStore, {\n      isUsernameClaimed: IsUsernameClaimedProjection(command.username),\n    })\n    if (state.isUsernameClaimed) {\n      throw new Error(`Username \"${command.username}\" is claimed`)\n    }\n    this.eventStore.append(\n      AccountRegistered({\n        username: command.username,\n      }),\n      appendCondition\n    )\n  }\n}\n</code></pre> Experimental: 3rd party library <p>These Given/When/Then scenarios are visualized using an unofficial, work-in-progress, library</p> <p></p>"},{"location":"examples/unique-username/#feature-4-username-retention","title":"Feature 4: Username retention","text":"<p>In the previous examples a username that is no longer claimed, can be used immediately again for new accounts. This example extends the previous one to show how the a username can be reserved for a configurable amount of time before it is released.</p> <p>Note</p> <p>The <code>daysAgo</code> property of the Event metadata is a simplification. Typically, a timestamp representing the Event's recording time is stored within the Event's payload or metadata. This timestamp can be compared to the current date to determine the Event's age in the decision model.</p> JavaScriptTypeScriptGWT (WIP) Info <p>This example uses composed projections to build Decision Models (explore library source code )</p> <p><pre><code>// event type definitions:\n\nfunction AccountRegistered({ username }) {\n  return {\n    type: \"AccountRegistered\",\n    data: { username },\n    tags: [`username:${username}`],\n  }\n}\n\nfunction AccountClosed({ username }) {\n  return {\n    type: \"AccountClosed\",\n    data: { username },\n    tags: [`username:${username}`],\n  }\n}\n\nfunction UsernameChanged({ oldUsername, newUsername }) {\n  return {\n    type: \"UsernameChanged\",\n    data: { oldUsername, newUsername },\n    tags: [`username:${oldUsername}`, `username:${newUsername}`],\n  }\n}\n\n// projections for decision models:\n\nfunction IsUsernameClaimedProjection(username) {\n  return createProjection({\n    initialState: false,\n    handlers: {\n      AccountRegistered: (state, event) =&gt; true,\n      AccountClosed: (state, event) =&gt; event.metadata?.daysAgo &lt;= 3,\n      UsernameChanged: (state, event) =&gt; event.data.newUsername === username || event.metadata?.daysAgo &lt;= 3,\n    },\n    tagFilter: [`username:${username}`],\n  })\n}\n\n// command handlers:\n\nclass Api {\n  eventStore\n  constructor(eventStore) {\n    this.eventStore = eventStore\n  }\n\n  registerAccount(command) {\n    const { state, appendCondition } = buildDecisionModel(this.eventStore, {\n      isUsernameClaimed: IsUsernameClaimedProjection(command.username),\n    })\n    if (state.isUsernameClaimed) {\n      throw new Error(`Username \"${command.username}\" is claimed`)\n    }\n    this.eventStore.append(\n      AccountRegistered({\n        username: command.username,\n      }),\n      appendCondition\n    )\n  }\n}\n\n// test cases:\n\nconst eventStore = new InMemoryDcbEventStore()\nconst api = new Api(eventStore)\nrunTests(api, eventStore, [\n  {\n    description: \"Register account with claimed username\",\n    given: {\n      events: [\n        AccountRegistered({\"username\":\"u1\"}),\n      ],\n    },\n    when: {\n      command: {\n        type: \"registerAccount\",\n        data: {\"username\":\"u1\"},\n      }\n    },\n    then: {\n      expectedError: \"Username \\\"u1\\\" is claimed\",\n    }\n  }, \n  {\n    description: \"Register account with unused username\",\n    when: {\n      command: {\n        type: \"registerAccount\",\n        data: {\"username\":\"u1\"},\n      }\n    },\n    then: {\n      expectedEvent: AccountRegistered({\"username\":\"u1\"}),\n    }\n  }, \n  {\n    description: \"Register account with username of closed account\",\n    given: {\n      events: [\n        AccountRegistered({\"username\":\"u1\"}),\n        AccountClosed({\"username\":\"u1\"}),\n      ],\n    },\n    when: {\n      command: {\n        type: \"registerAccount\",\n        data: {\"username\":\"u1\"},\n      }\n    },\n    then: {\n      expectedEvent: AccountRegistered({\"username\":\"u1\"}),\n    }\n  }, \n  {\n    description: \"Register account with a username that was previously used and then changed\",\n    given: {\n      events: [\n        AccountRegistered({\"username\":\"u1\"}),\n        UsernameChanged({\"oldUsername\":\"u1\",\"newUsername\":\"u1changed\"}),\n      ],\n    },\n    when: {\n      command: {\n        type: \"registerAccount\",\n        data: {\"username\":\"u1\"},\n      }\n    },\n    then: {\n      expectedEvent: AccountRegistered({\"username\":\"u1\"}),\n    }\n  }, \n  {\n    description: \"Register account with a username that another username was changed to\",\n    given: {\n      events: [\n        AccountRegistered({\"username\":\"u1\"}),\n        UsernameChanged({\"oldUsername\":\"u1\",\"newUsername\":\"u1changed\"}),\n      ],\n    },\n    when: {\n      command: {\n        type: \"registerAccount\",\n        data: {\"username\":\"u1changed\"},\n      }\n    },\n    then: {\n      expectedError: \"Username \\\"u1changed\\\" is claimed\",\n    }\n  }, \n  {\n    description: \"Register username of closed account before retention period\",\n    given: {\n      events: [\n        addEventMetadata(AccountRegistered({\"username\":\"u1\"}), {\"daysAgo\":4}),\n        addEventMetadata(AccountClosed({\"username\":\"u1\"}), {\"daysAgo\":3}),\n      ],\n    },\n    when: {\n      command: {\n        type: \"registerAccount\",\n        data: {\"username\":\"u1\"},\n      }\n    },\n    then: {\n      expectedError: \"Username \\\"u1\\\" is claimed\",\n    }\n  }, \n  {\n    description: \"Register changed username before retention period\",\n    given: {\n      events: [\n        addEventMetadata(AccountRegistered({\"username\":\"u1\"}), {\"daysAgo\":4}),\n        addEventMetadata(UsernameChanged({\"oldUsername\":\"u1\",\"newUsername\":\"u1changed\"}), {\"daysAgo\":3}),\n      ],\n    },\n    when: {\n      command: {\n        type: \"registerAccount\",\n        data: {\"username\":\"u1\"},\n      }\n    },\n    then: {\n      expectedError: \"Username \\\"u1\\\" is claimed\",\n    }\n  }, \n  {\n    description: \"Register username of closed account after retention period\",\n    given: {\n      events: [\n        addEventMetadata(AccountRegistered({\"username\":\"u1\"}), {\"daysAgo\":4}),\n        addEventMetadata(AccountClosed({\"username\":\"u1\"}), {\"daysAgo\":4}),\n      ],\n    },\n    when: {\n      command: {\n        type: \"registerAccount\",\n        data: {\"username\":\"u1\"},\n      }\n    },\n    then: {\n      expectedEvent: AccountRegistered({\"username\":\"u1\"}),\n    }\n  }, \n  {\n    description: \"Register changed username after retention period\",\n    given: {\n      events: [\n        addEventMetadata(AccountRegistered({\"username\":\"u1\"}), {\"daysAgo\":4}),\n        addEventMetadata(UsernameChanged({\"oldUsername\":\"u1\",\"newUsername\":\"u1changed\"}), {\"daysAgo\":4}),\n      ],\n    },\n    when: {\n      command: {\n        type: \"registerAccount\",\n        data: {\"username\":\"u1\"},\n      }\n    },\n    then: {\n      expectedEvent: AccountRegistered({\"username\":\"u1\"}),\n    }\n  }, \n])\n</code></pre> </p> Info <p>This example uses composed projections to build Decision Models (explore library source code )</p> <pre><code>// event type definitions:\n\nfunction AccountRegistered({\n  username,\n} : {\n  username: string,\n}) {\n  return {\n    type: \"AccountRegistered\" as const,\n    data: { username },\n    tags: [`username:${username}`],\n  }\n}\n\nfunction AccountClosed({\n  username,\n} : {\n  username: string,\n}) {\n  return {\n    type: \"AccountClosed\" as const,\n    data: { username },\n    tags: [`username:${username}`],\n  }\n}\n\nfunction UsernameChanged({\n  oldUsername,\n  newUsername,\n} : {\n  oldUsername: string,\n  newUsername: string,\n}) {\n  return {\n    type: \"UsernameChanged\" as const,\n    data: { oldUsername, newUsername },\n    tags: [`username:${oldUsername}`, `username:${newUsername}`],\n  }\n}\n\ntype EventTypes = ReturnType&lt;\n  | typeof AccountRegistered,\n  | typeof AccountClosed,\n  | typeof UsernameChanged,\n&gt;\n\n// projections for decision models:\n\nfunction IsUsernameClaimedProjection(username: string) {\n  return createProjection&lt;EventTypes, boolean&gt;({\n    initialState: false,\n    handlers: {\n      AccountRegistered: (state, event) =&gt; true,\n      AccountClosed: (state, event) =&gt; event.metadata?.daysAgo &lt;= 3,\n      UsernameChanged: (state, event) =&gt; event.data.newUsername === username || event.metadata?.daysAgo &lt;= 3,\n    },\n    tagFilter: [`username:${username}`],\n  })\n}\n\n// command handlers:\n\nclass Api {\n  constructor(private eventStore: EventStore) {}\n\n  registerAccount(command: { username: string }) {\n    const { state, appendCondition } = buildDecisionModel(this.eventStore, {\n      isUsernameClaimed: IsUsernameClaimedProjection(command.username),\n    })\n    if (state.isUsernameClaimed) {\n      throw new Error(`Username \"${command.username}\" is claimed`)\n    }\n    this.eventStore.append(\n      AccountRegistered({\n        username: command.username,\n      }),\n      appendCondition\n    )\n  }\n}\n</code></pre> Experimental: 3rd party library <p>These Given/When/Then scenarios are visualized using an unofficial, work-in-progress, library</p> <p></p>"},{"location":"examples/unique-username/#conclusion","title":"Conclusion","text":"<p>This example demonstrates how to solve one of the Event Sourcing evergreens: Enforcing unique usernames. But it can be applied to any scenario that requires global uniqueness of some sort.</p>"},{"location":"resources/","title":"Resources","text":"<p>This part of the website aims to collect additional resources, like custom implementations and links to other articles &amp; videos</p>"},{"location":"resources/#libraries","title":"Libraries","text":"<p>3rd party libraries that implement DCB Event Stores or related tools</p>"},{"location":"resources/#media","title":"Media","text":"<p>Videos and podcasts related to DCB</p>"},{"location":"resources/#articles","title":"Articles","text":"<p>External blog posts and articles related to the topic</p> <p>Tip</p> <p>Please let us know about any interesting resources by getting in touch or creating Pull Requests on the Github Repository of this website</p>"},{"location":"resources/articles/","title":"Articles","text":""},{"location":"resources/articles/#i-am-here-to-kill-the-aggregate","title":"I am here to kill the aggregate","text":"<p>Author: Sara Pellegrini, Published: April 2023</p>"},{"location":"resources/articles/#rethinking-microservices-architecture-through-dynamic-consistency-boundaries","title":"Rethinking Microservices Architecture Through Dynamic Consistency Boundaries","text":"<p>Publisher: AxonIQ, Published: August 2024</p>"},{"location":"resources/libraries/","title":"Libraries and tools","text":"<p>DCB is merely a set of ideas and concepts. But there are already a couple of libraries and libraries that prove those in practice:</p>"},{"location":"resources/libraries/#go","title":"Go","text":"<ul> <li><code>go-crablet</code></li> </ul>"},{"location":"resources/libraries/#java","title":"Java","text":"<ul> <li>AxonIQ  has announced to support DCB with version 5 of their Axon Framework (work in progress)</li> </ul>"},{"location":"resources/libraries/#javascripttypescript","title":"JavaScript/TypeScript","text":"<ul> <li><code>@dcb-es/event-store</code> (work in progress)</li> </ul>"},{"location":"resources/libraries/#php","title":"PHP","text":"<ul> <li><code>wwwision/dcb-eventstore</code> (work in progress)</li> <li><code>gember/event-sourcing</code> (work in progress)</li> </ul>"},{"location":"resources/libraries/#python","title":"Python","text":"<ul> <li>Event Sourcing in Python (work in progress)</li> </ul>"},{"location":"resources/libraries/#ruby","title":"Ruby","text":"<ul> <li><code>ortegacmanuel/kroniko</code> (work in progress)</li> </ul>"},{"location":"resources/libraries/#rust","title":"Rust","text":"<ul> <li>Disintegrate <code>disintegrate-es/disintegrate</code> (slightly different approach, inspired by the original ideas of DCB)</li> <li><code>dcbdb</code> (work in progress)</li> </ul>"},{"location":"resources/libraries/#add-your-own","title":"Add your own","text":"<p>If you are working on a library related to DCB or on a compatible (see specification) Event Store, feel free to open a Pull request in the Github Repository of this website to add it to the list above</p>"},{"location":"resources/media/","title":"Media","text":""},{"location":"resources/media/#videos","title":"Videos","text":""},{"location":"resources/media/#dynamic-consistency-boundaries-dcb-nie-wieder-aggregates-schneiden-golo-roden","title":"Dynamic Consistency Boundaries (DCB): Nie wieder Aggregates schneiden! - Golo Roden","text":"<p>Presenter: Golo Roden, Published: August 2025, Language: German</p>"},{"location":"resources/media/#kill-aggregate-volume-2-sara-pellegrini","title":"Kill Aggregate Volume 2 - Sara Pellegrini","text":"<p>Presenter: Sara Pellegrini, Published: June 2025, Conference: J On The Beach</p>"},{"location":"resources/media/#kill-aggregate-sara-pellegrini","title":"Kill Aggregate! - Sara Pellegrini","text":"<p>Presenter: Sara Pellegrini, Published: April 2023, Language: Italian (with English subtitles)</p>"},{"location":"resources/media/#should-you-build-your-own-event-sourcing-framework","title":"Should You Build Your Own Event Sourcing Framework?","text":"<p>Host: Shawn McCool, Guest: Bastian Waidelich, Published: November 2024</p>"},{"location":"resources/media/#making-event-sourcing-easy","title":"Making Event Sourcing Easy","text":"<p>Publisher: AxonIQ, Published: December 2024</p>"},{"location":"resources/media/#podcasts","title":"Podcasts","text":""},{"location":"resources/media/#the-event-modeling-and-event-sourcing-podcast","title":"The Event Modeling and Event Sourcing Podcast","text":"<p>This podcasts covers DCB in multiple episodes</p> <p>Hosts: Adam Dymitruk &amp; Martin Dilger</p>"},{"location":"topics/","title":"Related topics","text":"<p>This part of the website contains in-depth articles on additional subjects related to DCB:</p>"},{"location":"topics/#aggregates","title":"Aggregates","text":"<p>A definition of the pattern and why we consider DCB an evolution of the core ideas</p>"},{"location":"topics/#projections","title":"Projections","text":"<p>How DCB allows to compose projections in order to create dynamic Decision Models</p>"},{"location":"topics/#tags","title":"Tags","text":"<p>How tags are the key to flexible event correlation</p> <p>Tip</p> <p>We will add more articles over time, make sure to watch the Github Repository of this website to get notified about changes</p>"},{"location":"topics/aggregates/","title":"Aggregates","text":"<p>The idea of DCB started with the goal of killing the Aggregate .</p> <p>This article aims to explain our interpretation of the Aggregate pattern and why we consider it problematic.</p>"},{"location":"topics/aggregates/#what-is-an-aggregate","title":"What is an Aggregate?","text":"<p>An Aggregate, as described in DDD refers to:</p> <p>\"[...] a cluster of associated objects that we treat as a unit for the purpose of data changes\"   \u2013 Eric Evans, 2003 </p> <p>Its primary role is to enforce consistency.</p>"},{"location":"topics/aggregates/#consistency","title":"Consistency","text":"<p>While consistency broadly refers to the stability, coherence, and predictability of a system's state, the Aggregate Pattern focuses on a more specific meaning: creating a Decision Model used to ensure that business invariants are consistently enforced, even when multiple operations or users interact with the system concurrently.</p> <p>For example, let's assume that we want to ensure that a course must never be overbooked (sticking to the common theme of this website).</p> <p>A simple implementation in a classical, state-based architecture could look something like this (pseudo code):</p> <pre><code>course = db.loadCourse('c1')\nif (course.numberOfSubscribers &gt;= course.capacity) {\n    // fail\n}\ncourse.numberOfSubscribers ++\ndb.update(course)\n</code></pre> <p>This code is not thread-safe: between the execution of lines 2 and 6, a different process might already update the same course and violate the constraints as a result.</p> <p>To prevent these potential race conditions, there are two common approaches:</p>"},{"location":"topics/aggregates/#pessimistic-locking","title":"Pessimistic Locking","text":"<p>With Pessimistic Locking, a resource is locked as soon as it's accessed, preventing others from modifying it until the lock is released.</p> <p>With the current example, this could be achieved with a lock on the corresponding database table:</p> <pre><code>db.lockCourseTable()\ncourse = db.loadCourse('c1')\nif (course.numberOfSubscribers &gt;= course.capacity) {\n    // fail\n}\ncourse.numberOfSubscribers ++\ndb.update(course)\ndb.releaseCourseTableLock()\n</code></pre> <p>While this might seem tempting, it is not without problems because it might lead to deadlocks (which can happen as soon there are multiple locks and no consistent acquiring order). But, more importantly, It prevents any other course from being updated while the lock is active.</p> <p>Even if only the affected course were locked, it would prevent independent parallel changes (e.g. changing concurrently the course title and the course description).</p>"},{"location":"topics/aggregates/#optimistic-locking","title":"Optimistic Locking","text":"<p>With Optimistic Locking, multiple users can freely read and attempt to modify the same data. However, updates are only permitted if the data remains unchanged since it was read. This allows unrestricted reading, while writing faces similar constraints to pessimistic locking \u2014 but typically requires shorter database locks.</p> <p>It is usually achieved with a version number</p> <pre><code>course = db.loadCourse('c1')\nif (course.numberOfSubscribers &gt;= course.capacity) {\n    // fail\n}\ncourse.numberOfSubscribers ++\ndb.update(course, course.version)\n</code></pre> <p>The <code>update</code> call fails if the <code>version</code> was updated in the meantime.</p>"},{"location":"topics/aggregates/#the-aggregate-pattern","title":"The Aggregate Pattern","text":"<p>The Aggregate Pattern formalizes consistency boundaries by modeling them explicitly within the Domain Model, rather than relying on infrastructural low-level locking mechanisms.</p> <p>In this pattern, closely related domain entities and value objects are grouped into an Aggregate, with one entity designated as the Aggregate Root. The Aggregate Root serves as the exclusive access point, mediating all state changes. This ensures that all invariants and business rules are enforced consistently and atomically within the boundary of the Aggregate.</p> <p>A typical example is an <code>Order</code> Aggregate, where operations such as adding or removing line items are only performed through methods on the <code>Order</code> Aggregate Root. This guarantees that domain invariants\u2014such as the correctness of the total price\u2014are maintained at all times:</p> <p></p> <p>The <code>Order</code> is the Aggregate root. <code>Shipping Address</code> and <code>Order Items</code> are also part of the <code>Order</code> Aggregate</p> <p>Applied to the course example, we could model a <code>Course</code> as the Aggregate Root:</p> <p></p> <p>An Aggregate with the <code>Course</code> acting as Aggregate root with relations to <code>Student</code> entities</p> <p>However, embedding the <code>Student</code> entity within the <code>Course Aggregate</code> would be inappropriate, as it would imply that all modifications to a <code>Student</code> must be performed through the <code>Course Aggregate Root</code>. A more suitable approach is to model <code>Student</code> as a separate Aggregate, which aligns with the principle that Aggregates should encapsulate only tightly coupled data and behavior.</p> <p>This separation is feasible because it's perfectly valid for one Aggregate to reference another by its identifier:</p> <p></p> <p>Extracting the <code>Student</code> entity to a separate Aggregate, referenced by the Aggregate root identifier (<code>StudentId</code>)</p>"},{"location":"topics/aggregates/#limitations","title":"Limitations","text":"<p>This pattern enforces, by design, that state changes are confined to a single Aggregate instance per transactional boundary. Or, as Eric Evans puts it:</p> <p>\"Any rule that spans Aggregates will not be expected to be always up to date. Through event processing, batch processing, or other update mechanisms, other dependencies can be resolved within some specified time. But the invariants applied within an Aggregate will be enforced with the completion of each transaction\"   \u2013 Eric Evans, 2003 </p> <p>This restriction is acceptable as long as an operation impacts only the invariants encapsulated within a single Aggregate. However, there are scenarios where this assumption breaks down. Consider extending the previous example with an additional business rule:</p> <ul> <li>A student must not be enrolled in more than 10 courses</li> </ul> <p>With that, subscribing a student affects the invariants of two Aggregates.</p> <p>Note</p> <p>In some cases, such challenges indicate poorly defined Aggregate boundaries. However, in this scenario, restructuring the model \u2014 for example, by introducing a <code>Subscription</code> Aggregate \u2014 would not resolve the issue, since the business invariants related to both <code>Course</code> and <code>Student</code> must still be enforced independently within their respective Aggregates.</p> <p>Likewise, making the Aggregate larger, covering more entities and value objects, is not a real option in this situation. Indeed, it would mean creating a single aggregate that includes all courses and all students, to cover any possible subscription. However, this has the obvious drawback of reducing scalability, cohesion, and the degree of parallel processing.</p> <p>In a traditional persistence model, one possible workaround would be to lock both affected records in the database to ensure consistency. However, this approach directly violates the pattern and introduces a host of other issues:</p> <p>\"Relational databases allow various locking schemes, and special tests can be programmed. But these ad-hoc solutions quickly divert attention away from the model, and soon you are back to hacking and hoping.\" \u2013 Eric Evans, 2003 </p> <p>Instead, the typical solution in such cases is to decompose the process into a series of coordinated steps. This means dropping the strong consistency of all the invariants and accepting partial updates that will be eventually reverted by corrective Events if needed. While this approach can work, it introduces significant complexity and can lead to invalid intermediate states until the compensating action is executed. Moreover, in event-driven architectures, this strategy leads to the generation of additional Events that, although necessary from a technical perspective, don't correspond to meaningful business interactions.</p>"},{"location":"topics/aggregates/#event-sourced-aggregate","title":"Event-Sourced Aggregate","text":"<p>With Event Sourcing, strong consistency is usually enforced using optimistic concurrency:</p> <ul> <li>Relevant Events are loaded, remembering the position of the last consumed Event</li> <li>A decision is made based on the projected state of those Events</li> <li>If successful, a new Event is appended specifying the remembered position</li> <li>The Event Store appends the new Event only if no other Event was stored in the meantime and fails otherwise</li> <li>Upon failure the process can be repeated until the Event was successfully persisted</li> </ul>"},{"location":"topics/aggregates/#event-streams","title":"Event Streams","text":"<p>With only one global Event Stream, all actions would be forced through a single sequence, ruling out parallel execution entirely. That can be compared to a single Aggregate that covers all entities of the application.</p> <p>To work around this, the Events are partitioned into sub Event Streams, which each Event being assigned to a single Stream and the position (aka \"sequence number\", \"version\" or \"revision\") the Event has in that Stream \u2013 in addition to the global position:</p> <p></p> <p>Each Event is assigned to a single Stream and contains the position in that Stream as well as the global position</p> <p>The Event Store appends new Events only if the last Event in the same Event Stream is equal to the specified position and fails otherwise. This way it can guarantee transaction safety for one Event Stream at a time.</p> <p>This makes the Event Stream a good match for Aggregates, as demonstrated in the previous illustration: Course-Events are persisted to Streams of the corresponding Aggregate instance \"<code>course-&lt;courseIdentifier&gt;</code>\"</p>"},{"location":"topics/aggregates/#consequences","title":"Consequences","text":"<p>While Event-Sourced Aggregates bring powerful capabilities, it's important to recognize that they are subject to the same limitations as traditional Aggregates. In fact, their boundaries tend to be even more rigid, as they become materialized in the structure of the Event Streams. This rigidity can make it significantly harder to adapt the design later on, especially as the model evolves and new insights emerge.</p> <p>We believe that flexibility is essential in software design \u2014 it should leave room for mistakes, experimentation, and new realizations as understanding deepens over time. Additionally, Event-Sourced Aggregates often grow in size as more Events accumulate, which can negatively impact performance. Although there are mitigation strategies, such as snapshots or patterns like \"closing the books\", they often come at the cost of added complexity.</p>"},{"location":"topics/aggregates/#relation-to-dcb","title":"Relation to DCB","text":"<p>Dynamic Consistency Boundaries offer an alternative approach by allowing consistency to be enforced for a specific use case, rather than being hardwired into a static Aggregate structure. This is where the \"dynamic\" aspect comes in \u2014 not because the consistency is weaker or less accurate, but because the boundary is established at runtime, tailored to the requirements of a single interaction.</p> <p>As a result, only the Events that are necessary to evaluate those invariants are loaded and considered, improving flexibility and potentially reducing overhead.</p> <p>In essence, DCB makes it possible to construct a Decision Model dynamically, just for the duration of an operation, to guard the relevant invariants.</p>"},{"location":"topics/aggregates/#killing-it-really","title":"Killing it, really?","text":"<p>While the phrase \"Killing the Aggregate\" might sound provocative, we don\u2019t view DCB as a rejection of the Aggregate pattern. On the contrary, we see it as an evolution \u2014 one that preserves the core intent of Aggregates, especially when viewed from the perspective of a single interaction.</p> <p>That said, we've chosen not to overload the term \u201cAggregate\u201d any further, especially given the existing ambiguity and varied interpretations in the community. Instead, we often refer to this construct as a Decision Model, emphasizing its role in evaluating business rules and producing decisions in a specific context.</p> <p> </p> The Aggregate is dead, long live the Aggregate"},{"location":"topics/aggregates/#conclusion","title":"Conclusion","text":"<ul> <li>It is important to think about consistency boundaries and hard vs soft constraints when building software</li> <li>The Aggregate pattern allows to make this part of the Domain Model</li> <li>It is, however, very rigid \u2013 especially with the Event Sourced Aggregate</li> <li>DCB allows to enforce explicit boundaries for a specific use case</li> <li>Thus it is much more flexible because to build the Decision Model by composing Projections</li> <li>DCB can be used without breaking the Aggregate pattern, and still gain advantages</li> </ul>"},{"location":"topics/projections/","title":"Projections","text":"<p>In software architecture, how we view and handle data often comes down to two fundamental perspectives: event-based and state-based. The state-based view focuses on the current snapshot of data. It\u2019s straightforward and efficient for querying, reporting, and displaying data to users. In contrast, the event-based view captures every change over time, providing a complete history of how the state evolved.</p> <p>Depending on your use case, one view may serve better than the other \u2014 or you might need both. That\u2019s where projections come in: they translate an event-based history into a state-based model tailored to specific needs.</p> <p>The result is commonly used for persistent Read Models. In Event Sourcing, however, projections are also used to build the Decision Model needed to enforce consistency constraints. </p> <p>This website typically refers to this latter kind of projection since DCB primarily focuses on ensuring the consistency of the Event Store during write operations.</p> <p>This article explains how to write projections that can be queried by a DCB-capable Event Store, and how to compose those projections in a way that keeps them simple and reusable.</p>"},{"location":"topics/projections/#what-is-a-projection","title":"What is a Projection","text":"<p>In 2013 Greg Young posted the following minimal definition of a projection:</p> <p></p> <p>Greg Young, 2013 on Twitter/X </p> <p>In TypeScript the equivalent Type definition would be:</p> <pre><code>type Projection&lt;S, E&gt; = (state: S, event: E) =&gt; S\n</code></pre>"},{"location":"topics/projections/#implementation","title":"Implementation","text":"<p>Note</p> <p>To use a common theme, we refer to Events from the course subscription example:</p> <ul> <li>new courses can be added (<code>CourseDefined</code>)</li> <li>courses can be archived (<code>CourseArchived</code>)</li> <li>courses can be renamed (<code>CourseRenamed</code>)</li> </ul> <p>We use JavaScript in the examples below, but the main ideas are applicable to all programming languages</p> <p>A typical DCB projection might look something like this:</p> <pre><code>{\n  initialState: null,\n  handlers: {\n    CourseDefined: (state, event) =&gt; event.data.title,\n    CourseRenamed: (state, event) =&gt; event.data.newTitle,\n  },\n  tags: [`course:${courseId}`],\n}\n</code></pre> <p>Let's see how we got here...</p>"},{"location":"topics/projections/#basic-functionality","title":"Basic functionality","text":"<p>To start simple, we can implement Events as an array of strings:</p> <p><pre><code>const events = [\n  \"CourseDefined\",\n  \"CourseDefined\",\n  \"CourseRenamed\",\n  \"CourseArchived\",\n  \"CourseDefined\"\n]\n</code></pre> </p> <p>In order to find out how many active courses there are in total, the following simple projection could be defined and we can use JavaScripts <code>reduce</code> function to aggregate all Events creating a single state, starting with the <code>initialState</code>:</p> <p><pre><code>// ...\nconst projection = (state, event) =&gt; {\n  switch (event) {\n    case 'CourseDefined':\n      return state + 1;\n    case 'CourseArchived':\n      return state - 1;\n    default:\n      return state;\n  }\n}\nconst initialState = 0\nconst numberOfActiveCourses = events.reduce(projection, initialState)\n\nconsole.log({numberOfActiveCourses})\n</code></pre> </p> <p>Note</p> <p>A projection function has to be pure, i.e. it must be free of side effects in order to produce deterministic results. When replaying a projection for the same events, the resulting <code>state</code> has to be the same every time</p>"},{"location":"topics/projections/#query-only-relevant-events","title":"Query only relevant Events","text":"<p>In the above example, the reducer iterates over all Events even though it only changes the state for <code>CourseDefined</code> and <code>CourseArchived</code> events. This is not an issue for this simple example. But in reality, those events are not stored in memory, and there can be many of them. So obviously, they should be filtered before they are read from the Event Store.</p> <p>As previously mentioned, in the context of DCB, projections are typically used to reconstruct the minimal model required to validate the constraints the system needs to enforce \u2014 usually in response to a command issued by the user.</p> <p>Given that the system should ensure a performant response to user input, it becomes clear how paramount it is to minimize the time and effort needed to rebuild the Decision Model. The most effective approach, then, is to limit the reconstruction to the absolute minimum, by loading only the Events that are relevant to validating the received command.</p>"},{"location":"topics/projections/#filter-events-by-type","title":"Filter Events by Type","text":"<p>The Event Type is the main criteria for filtering Events before reading them from an Event Store.</p> <p>By defining the Event handlers more declaratively, the handled Event Types can be determined from the projection definition itself:</p> <p><pre><code>const projection = {\n  initialState: 0,\n  handlers: {\n    CourseDefined: (state, event) =&gt; state + 1,\n    CourseArchived: (state, event) =&gt; state - 1,\n  }\n}\n\n// filter events (should exclude \"CourseRenamed\" events)\nconsole.log(\n  events.filter((event) =&gt;\n      event in projection.handlers\n  )\n)\n</code></pre> </p>"},{"location":"topics/projections/#filter-events-by-tags","title":"Filter Events by Tags","text":"<p>Decision Models are usually only concerned about single entities. E.g. in order to determine whether a course with a specific id exists, it's not appropriate to read all <code>CourseDefined</code> events but only those related to the course in question.</p> <p>This could be done with a projection like this: <pre><code>const projection = {\n  initialState: false,\n  handlers: {\n    CourseDefined: (state, event) =&gt; event.data.courseId === courseId ? true : state,\n    CourseArchived: (state, event) =&gt; event.data.courseId === courseId ? false : state,\n  }\n}\n</code></pre> But this is not a good idea because all <code>CourseDefined</code> Events would have to be loaded still.</p> <p>A traditional Event Store usually allows to partition Events into Event Streams (sometimes called subjects).</p> <p>In DCB there is no concept of multiple streams, Events are stored in a single global sequence. Instead, with DCB Events can be associated with entities (or other domain concepts) using Tags. And a compliant Event Store allows to filter Events by their Tags, in addition to their Type.</p> <p>To demonstrate that, we add Data and Tags to the example Events:</p> <p><pre><code>const events = [\n  {\n    type: \"CourseDefined\",\n    data: { id: \"c1\", title: \"Course 1\", capacity: 10 },\n    tags: [\"course:c1\"],\n  },\n  {\n    type: \"CourseDefined\",\n    data: { id: \"c2\", title: \"Course 2\", capacity: 20 },\n    tags: [\"course:c2\"],\n  },\n  {\n    type: \"CourseRenamed\",\n    data: { id: \"c1\", newTitle: \"Course 1 renamed\" },\n    tags: [\"course:c1\"],\n  },\n  {\n    type: \"CourseArchived\",\n    data: { id: \"c2\" },\n    tags: [\"course:c2\"],\n  },\n]\n</code></pre> </p> <p>...and extend the projection by some <code>tagFilter</code>:</p> <pre><code>const projection = {\n  initialState: false,\n  handlers: {\n    CourseDefined: (state, event) =&gt; true,\n    CourseArchived: (state, event) =&gt; false,\n  },\n  tagFilter: [`course:c1`]\n}\n\n// filter events (should only include \"CourseDefined\" and \"CourseArchived\" events with a tag of \"course:c1\")\nconsole.log(\n  events.filter((event) =&gt;\n      event.type in projection.handlers &amp;&amp;\n      projection.tagFilter.every((tag) =&gt; event.tags.includes(tag))\n  )\n)\n</code></pre> <p></p> <p>In the above example, the projection is hard-coded to filter events tagged <code>course:c1</code>. In a real application, the <code>tagFilter</code> is the most dynamic part of the projection as it depends on the specific use case, i.e. the affected entity instance(s). So it makes sense to create some kind of factory that allows to pass in the relevant dynamic information (the course id in this case):</p> <pre><code>const CourseExistsProjection = (courseId) =&gt; ({\n  initialState: false,\n  handlers: {\n    // ...\n  },\n  tagFilter: [`course:${courseId}`]\n})\n</code></pre>"},{"location":"topics/projections/#library","title":"Library","text":"<p>We have built a small library  that provides functions to create projections and test them.</p> <p>The <code>createProjection</code> function accepts a projection object like we defined above:</p> <pre><code>const CourseExistsProjection = (courseId) =&gt;\n  createProjection({\n    initialState: false,\n    handlers: {\n      CourseDefined: (state, event) =&gt; true,\n      CourseArchived: (state, event) =&gt; false,\n    },\n    tagFilter: [`course:${courseId}`],\n  })\n</code></pre> <p></p> <p>The resulting object can be used to easily filter events and to build the projection state:</p> <pre><code>const projection = CourseExistsProjection(\"c1\")\n\nconsole.log(\"query:\", projection.query.items)\nconsole.log(\"initialState:\", projection.initialState)\n\nconst state = events\n  .filter((event) =&gt; projection.query.matchesEvent(event))\n  .reduce(\n    (state, event) =&gt; projection.apply(state, event),\n    projection.initialState\n  )\n\nconsole.log(\"projected state:\", state)\n</code></pre> <p></p> <p>Similarly a projection for the current <code>title</code> of a course would look like this:</p> <p><pre><code>const CourseTitleProjection = (courseId) =&gt;\n  createProjection({\n    initialState: null,\n    handlers: {\n      CourseDefined: (state, event) =&gt; event.data.title,\n      CourseRenamed: (state, event) =&gt; event.data.newTitle,\n    },\n    tagFilter: [`course:${courseId}`],\n  })\n</code></pre> </p> The library is not a requirement <p>This library   is not required in order to use DCB, but we'll use it in this article and in some of the other examples in order to keep them simple.</p> <p>The <code>createProjection</code> function returns an object with the following properties:</p> <pre><code>type Projection&lt;S&gt; = {\n  get initialState(): S\n  apply(state: S, event: SequencedEvent): S\n  get query(): Query\n}\n</code></pre> <p>The <code>Query</code> can be used to \"manually\" filter events, like in the example above. In a productive application it will be translated to a query that the corresponding Event Store can execute.</p>"},{"location":"topics/projections/#composing-projections","title":"Composing projections","text":"<p>As mentioned above, these in-memory projections can be used to build Decision Models that can be used to enforce hard constraints.</p> <p>So far, the example projections in this article were only concerned about a very specific question, e.g. whether a given course exists. Usually, there are multiple hard constraints involved though. For example: In the course subscription example in order to change a courses capacity, we have to ensure that...</p> <ul> <li>...the course exists</li> <li>...and that the specified new capacity is different from the current capacity</li> </ul> <p>It is tempting to write a slightly more sophisticated projection that can answer both questions, like:</p> <pre><code>const CourseProjection = (courseId) =&gt;\n  createProjection({\n    initialState: { courseExists: false, courseCapacity: 0 },\n    handlers: {\n      CourseDefined: (state, event) =&gt; ({\n        courseExists: true,\n        courseCapacity: event.data.capacity,\n      }),\n      CourseCapacityChanged: (state, event) =&gt; ({\n        ...state,\n        courseCapacity: event.data.newCapacity,\n      }),\n    },\n    tagFilter: [`course:${courseId}`],\n  })\n\nconst courseProjection = CourseProjection(\"c1\")\nconst state = events\n  .filter((event) =&gt; courseProjection.query.matchesEvent(event))\n  .reduce(courseProjection.apply, courseProjection.initialState)\n\nconsole.log(state)\n</code></pre> <p></p> <p>But that has some drawbacks, namely:</p> <ul> <li>It increases complexity of the projection code and makes it harder to reason about</li> <li>It makes the projection more \"greedy\", i.e. if it was used to make a decision based on parts of the state it would consume more events than required and increase the consistency boundary needlessly (see article about Aggregates for more details)</li> </ul> <p>Instead, the <code>composeProjections</code> function allows to combine multiple smaller projections into one, depending on the use case:</p> <pre><code>const compositeProjection = composeProjections({\n  courseExists: CourseExistsProjection(\"c1\"),\n  courseTitle: CourseTitleProjection(\"c1\"),\n})\n\nconsole.log(\"initial state:\", compositeProjection.initialState)\n\nconst state = events\n  .filter((event) =&gt; compositeProjection.query.matchesEvent(event))\n  .reduce(compositeProjection.apply, compositeProjection.initialState)\n\nconsole.log(\"projected state:\", state)\n</code></pre> <p></p> <p>As you can see, the state of the composite projection is an object with a key for every projection of the composition. Likewise, the resulting query will match only Events that are relevant for at least one of the composed projections.</p>"},{"location":"topics/projections/#how-to-use-this-with-dcb","title":"How to use this with DCB","text":"<p>In the context of DCB, composite projections are particularly useful for building Decision Models that require strong consistency.</p> <p>A lightweight translation layer can extract a query that efficiently loads only the events relevant to the composed projections.</p> <p>The <code>buildDecisionModel</code> function from the library mentioned above handles this for example: it lets you compose multiple projections dynamically, allowing to enforce dynamic consistency boundaries that inspired the name DCB:</p> <pre><code>const eventStore = new InMemoryDcbEventStore()\n\nconst { state, appendCondition } = buildDecisionModel(eventStore, {\n  courseExists: CourseExistsProjection(\"c1\"),\n  courseTitle: CourseTitleProjection(\"c1\"),\n})\n\nconsole.log(\"state:\", state)\nconsole.log(\"append condition:\", appendCondition)\n</code></pre> <p></p> <p>Note</p> <p>The <code>state</code> will contain the composed state of all projections.</p> <p>The <code>appendCondition</code> can be passed to the <code>append()</code> method of the DCB capable event store in order to enforce consistency (see specification for more details)</p>"},{"location":"topics/projections/#conclusion","title":"Conclusion","text":"<p>Projections play a fundamental role in DCB and Event Sourcing as a whole. The ability to combine multiple simple projections into more complex ones tailored to specific use cases unlocks a range of possibilities that can influence application design.</p>"},{"location":"topics/tags/","title":"Tags: The Key to Flexible Event Correlation","text":"<p>The concept of Dynamic Consistency Boundaries resonated with developers who had struggled with the rigid limitations of traditional Aggregate patterns. One area that deserves some additional clarification is the notion of tags.</p> <p>This article aims to shed light on why tags are not just a technical detail, but a core concept for implementing a DCB-compliant Event Store.</p>"},{"location":"topics/tags/#tldr","title":"TL;DR","text":"<ul> <li>Tags are explicit references to domain concepts involved in consistency rules</li> <li>They enable precise, performant event selection without relying on deep payload inspection</li> <li>While tags introduce a conceptual layer, we believe their benefits for scalability and correctness outweigh the added complexity</li> </ul>"},{"location":"topics/tags/#understanding-the-role-of-tags","title":"Understanding the Role of Tags","text":"<p>To understand why tags are essential, we need to distinguish between two different aspects of events:</p> <ul> <li>Event types represent the kind of state change that occurred (e.g., <code>order placed</code>, <code>inventory reserved</code>, <code>payment processed</code>)</li> <li>Tags help correlate events with specific instances in the domain (e.g., <code>product:laptop-x1</code>, <code>customer:alice-smith</code>, <code>warehouse:eu-west</code>)</li> </ul> <p>While an event type tells us what happened, tags tell us to whom or to what it happened. This distinction becomes crucial when we need to enforce business invariants.</p> <p>In short: A tag is a reference to a unique instance of a concept involved in a domain integrity rule.</p>"},{"location":"topics/tags/#the-problem-precise-event-selection-for-invariant-enforcement","title":"The Problem: Precise Event Selection for Invariant Enforcement","text":"<p>Consider an e-commerce system with a critical business rule:</p> <ul> <li>A product's available inventory cannot go below zero</li> </ul> <p>To enforce this invariant when processing a new <code>inventory reserved</code> event, we need to make decisions based on previously committed events. But which events exactly?</p> <p>To check if we can fulfill a reservation request, we need to examine all previous events that affected the specific product's stock levels: previous reservations, releases, restocks, and adjustments.</p> <p>The precision of this selection is critical:</p>"},{"location":"topics/tags/#missing-events-broken-invariants","title":"Missing Events = Broken Invariants","text":"<p>If we fail to include relevant events in our decision-making process, we risk violating business rules. Imagine checking product inventory but missing some reservation events \u2013 we might oversell products and create backorders.</p>"},{"location":"topics/tags/#too-many-events-scalability-problems","title":"Too Many Events = Scalability Problems","text":"<p>Conversely, if we include too many events in our consistency boundary, we create unnecessarily broad constraints that block parallel, unrelated decisions. This might be acceptable in some scenarios, but it severely limits scalability.</p> <p>For instance, if enforcing inventory constraints required locking all events for all products, then no two orders could be processed simultaneously anywhere in the system \u2013 even for completely different product categories.</p>"},{"location":"topics/tags/#traditional-event-store-limitations","title":"Traditional Event Store Limitations","text":"<p>Traditional Event Stores typically allow querying events by their stream (and sometimes by type as well). This approach leads to the very issues that DCB aims to solve, as detailed in our article about aggregates.</p>"},{"location":"topics/tags/#alternative-approaches-and-their-shortcomings","title":"Alternative Approaches and Their Shortcomings","text":"<p>One might wonder: couldn't we solve this with a query language that filters events by their payload properties? This is certainly possible and some Event Stores already offer this capability.</p> <p>But it introduces some challenges:</p>"},{"location":"topics/tags/#opaque-event-payloads","title":"Opaque Event Payloads","text":"<p>The event payload should remain opaque to the Event Store. It could even be stored in binary format for efficiency or encrypted for security/privacy reasons. Requiring the Event Store to parse and understand payload structure violates this principle.</p>"},{"location":"topics/tags/#complexity-overhead","title":"Complexity Overhead","text":"<p>A query language introduces substantial complexity on both the implementation and usage sides. Event Store implementations become more complex, and developers must learn and maintain knowledge of yet another query syntax.</p> <p>For example: A query to determine whether a username is claimed for the Unique username example could look like this:</p> <pre><code>(\n  (\n    event.type IN (\"AccountRegistered\", \"AccountClosed\")\n    AND\n    event.data.username == \"&lt;username&gt;\"\n  )\n  OR (\n    event.type == \"UsernameChanged\"\n    AND\n    event.data.newUsername == \"&lt;username&gt;\"\n  )\n)\n</code></pre> <p>while the corresponding DCB query would be:</p> <pre><code>[{\n  \"event_types\": [\"AccountRegistered\", \"AccountClosed\", \"UsernameChanged\"],\n  \"tags\": [\"&lt;username-tag&gt;\"]\n}]\n</code></pre>"},{"location":"topics/tags/#performance-challenges","title":"Performance Challenges","text":"<p>Dynamic queries against schemaless events make it extremely difficult to create performant implementations. Without predictable query patterns, the Event Store cannot optimize indexes or data structures effectively.</p>"},{"location":"topics/tags/#feature-incompleteness","title":"Feature Incompleteness","text":"<p>Any query language will inevitably have limitations. Comparing dates, working with sets or maps, handling null values... There will always be edge cases and missing operators that force workarounds or compromise.</p>"},{"location":"topics/tags/#inference-vs-query-complexity","title":"Inference vs. Query Complexity","text":"<p>Importantly, tags and event types don't need to be hardcoded into domain-specific logic. Instead, they can be inferred automatically from the types for example by using interfaces or dedicated types for the tagged properties.</p> Examples: Inferring tags from events <p>This inference becomes much more challenging \u2013 if not impossible \u2013 with complex, dynamic queries.</p>"},{"location":"topics/tags/#using-interfaces","title":"Using interfaces","text":"<p>The following C# example demonstrates how interfaces could be used to represent tagged events:</p> <pre><code>// interface definitions\ninterface IDomainEvent { }\n\ninterface ICourseEvent : IDomainEvent\n{\n    string CourseId { get; }\n}\n\ninterface IStudentEvent : IDomainEvent\n{\n    string StudentId { get; }\n}\n\n// function to extract tags from an event instance:\nstatic List&lt;string&gt; ExtractTags(IDomainEvent domainEvent)\n{\n    var tags = new List&lt;string&gt;();\n    if (domainEvent is IStudentEvent studentEvent)\n    {\n        tags.Add($\"student:{studentEvent.StudentId}\");\n    }\n    if (domainEvent is ICourseEvent courseEvent)\n    {\n        tags.Add($\"course:{courseEvent.CourseId}\");\n    }\n    return tags;\n}\n\n// event definition\nsealed record StudentSubscribedToCourse(string StudentId, string CourseId) : IStudentEvent, ICourseEvent;\n\n// usage\nIDomainEvent domainEvent = new StudentSubscribedToCourse(\"s1\", \"c1\");\nConsole.WriteLine(String.Join(\", \", ExtractTags(domainEvent))); // student:s1, course:c1\n</code></pre>"},{"location":"topics/tags/#using-custom-types","title":"Using custom types","text":"<p>The following TypeScript example demonstrates how custom types can be used to represent tags within events:</p> <pre><code>// type definitions\ninterface Tagged {\n  readonly value: string\n  readonly __tagPrefix: string\n  toJSON(): string\n}\n\ninterface CourseId extends Tagged {\n  readonly __tagPrefix: \"course\"\n}\n\ninterface StudentId extends Tagged {\n  readonly __tagPrefix: \"student\"\n}\n\nfunction createCourseId(value: string): CourseId {\n  return {\n    value,\n    __tagPrefix: \"course\" as const,\n    toJSON() {\n      return this.value\n    },\n  }\n}\n\nfunction createStudentId(value: string): StudentId {\n  return {\n    value,\n    __tagPrefix: \"student\" as const,\n    toJSON() {\n      return this.value\n    },\n  }\n}\n\n// function to extract tags from an event instance:\nfunction extractTags(eventData: Record&lt;string, unknown&gt;): string[] {\n  return Object.entries(eventData).reduce&lt;string[]&gt;(\n    (tags, [_, property]) =&gt;\n      property &amp;&amp; typeof property === \"object\" &amp;&amp; \"__tagPrefix\" in property\n        ? [\n            ...tags,\n            `${(property as Tagged).__tagPrefix}:${(property as Tagged).value}`,\n          ]\n        : tags,\n    []\n  )\n}\n\n// event definition\nfunction StudentSubscribedToCourse(studentId: StudentId, courseId: CourseId) {\n  return {\n    type: \"StudentSubscribedToCourse\" as const,\n    data: { studentId, courseId },\n  }\n}\n\n// usage\nconst event = StudentSubscribedToCourse(\n  createStudentId(\"s1\"),\n  createCourseId(\"c1\")\n)\nconsole.log(extractTags(event.data)) // [ 'student:s1', 'course:c1' ]\n</code></pre>"},{"location":"topics/tags/#guideline-for-good-tags","title":"Guideline for Good Tags","text":"<p>In most cases, it's fairly obvious which tags to add to an event type. If an event affects one or more entities, their identifiers typically make appropriate tags.</p> <p>In some cases, however, it's less straightforward \u2013 especially when constraints relate to more implicit concepts like email addresses, usernames, time slots or hierarchical relationships rather than concrete entities. In those situations, identifying the aggregate root (in Domain-Driven Design terms) can help clarify which tags are relevant.</p> <p>As a general rule, whenever a hard constraint depends on an event being included in a Decision Model, the necessary tags must be present. That said, it can be useful to proactively tag additional values that might become relevant for constraints in the future.</p> <p>Good tags follow these principles:</p> <ul> <li>Tags must be derivable from the event payload</li> <li>Prefixes (e.g., <code>customer:c123</code>, <code>order-1234</code>) help disambiguate values and standardize tag structure</li> <li>Tags should avoid personal data \u2013 hash or anonymize sensitive values like usernames and email addresses</li> </ul>"},{"location":"topics/tags/#benefits-of-the-tag-based-approach","title":"Benefits of the Tag-Based Approach","text":""},{"location":"topics/tags/#precise-consistency-boundaries","title":"Precise Consistency Boundaries","text":"<p>Tags allow us to define exactly which events are relevant for a particular decision, creating precise consistency boundaries that include all necessary data while excluding irrelevant events.</p>"},{"location":"topics/tags/#performance-optimization","title":"Performance Optimization","text":"<p>Since tags are explicitly declared and have predictable patterns, Event Stores can optimize storage and indexing strategies. This enables efficient querying even at scale.</p>"},{"location":"topics/tags/#automatic-inference","title":"Automatic Inference","text":"<p>DCB libraries will be able to automatically infer required tags and event types from domain model definitions, reducing the burden on developers while ensuring correctness.</p>"},{"location":"topics/tags/#acknowledging-the-limitations","title":"Acknowledging the Limitations","text":"<p>While we've outlined the benefits of tags, it's important to acknowledge that this approach isn't without its drawbacks:</p>"},{"location":"topics/tags/#the-name-itself","title":"The Name Itself","text":"<p>The term \"tags\" might not be optimal. It carries connotations from other domains (HTML tags, social media hashtags) that don't perfectly align with their role in event correlation. However, this is largely a semantic concern \u2013 DCB implementations are free to choose alternative terminology that better fits their context.</p>"},{"location":"topics/tags/#a-technical-compromise","title":"A Technical Compromise","text":"<p>Despite all the mentioned benefits, we must recognize that tags stem primarily from a technical requirement rather than emerging naturally from domain modeling. They represent an additional layer of abstraction that developers must understand and maintain.</p> <p>Tags are, fundamentally, our current best compromise for solving the event correlation problem in DCB systems. They balance the competing demands of:</p> <ul> <li>Precise event selection for invariant enforcement</li> <li>Performance and scalability requirements  </li> <li>Implementation complexity</li> <li>Domain model flexibility</li> </ul> <p>We acknowledge that this solution adds conceptual overhead to Event Store design and usage. While we believe the benefits justify this complexity, we remain open to alternative approaches that might solve these problems more elegantly.</p> <p>If you can think of alternative solutions that address the core challenges without requiring explicit tagging mechanisms, we'd be very interested to hear from you.</p>"}]}